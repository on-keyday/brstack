// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct ProtocolNumber(u8);
impl ProtocolNumber  {
    pub const ICMP:Self = Self(1);
    pub const TCP:Self = Self(6);
    pub const UDP:Self = Self(17);
}
impl std::fmt::Display for ProtocolNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProtocolNumber::ICMP => write!(f, "{}", "ICMP"),
            ProtocolNumber::TCP => write!(f, "{}", "TCP"),
            ProtocolNumber::UDP => write!(f, "{}", "UDP"),
            _ => write!(f, "ProtocolNumber({})",self.0),
        }
    }
}
impl std::convert::From<ProtocolNumber> for std::option::Option<&str> {
    fn from(e: ProtocolNumber) -> Self {
        match e {
            ProtocolNumber::ICMP => Some("ICMP"),
            ProtocolNumber::TCP => Some("TCP"),
            ProtocolNumber::UDP => Some("UDP"),
            _ =>  None,
        }
    }
}
impl ProtocolNumber {
    pub fn is_known(&self) -> bool {
        match *self {
            ProtocolNumber::ICMP => true,
            ProtocolNumber::TCP => true,
            ProtocolNumber::UDP => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for ProtocolNumber {
    fn from(e: u8) -> Self {
        Self(e)
    }
}
impl std::convert::From<ProtocolNumber> for u8 {
    fn from(e: ProtocolNumber) -> Self {
        e.0
    }
}
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_STATE */
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl <'a>IPv4Header<'a> {
    pub fn version(&self) -> u8 {
        ((self.field_3>>4) & 15) as u8}
    pub fn set_version(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 = self.field_3& !(15<< 4) | ((value as u8) << 4);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ihl(&self) -> u8 {
        ((self.field_3>>0) & 15) as u8}
    pub fn set_ihl(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 = self.field_3& !(15<< 0) | ((value as u8) << 0);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dscp(&self) -> u8 {
        ((self.field_4>>2) & 63) as u8}
    pub fn set_dscp(&mut self, value: u8) -> bool {
        if value > 63 {
        return false;
        }
        self.field_4 = self.field_4& !(63<< 2) | ((value as u8) << 2);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ecn(&self) -> u8 {
        ((self.field_4>>0) & 3) as u8}
    pub fn set_ecn(&mut self, value: u8) -> bool {
        if value > 3 {
        return false;
        }
        self.field_4 = self.field_4& !(3<< 0) | ((value as u8) << 0);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn reserved(&self) -> bool {
        ((self.field_5>>15) & 1) as u8 != 0}
    pub fn set_reserved(&mut self, value: bool) -> bool {
        self.field_5 = self.field_5& !(1<< 15) | ((if value {1} else {0} as u16) << 15);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dont_fragment(&self) -> bool {
        ((self.field_5>>14) & 1) as u8 != 0}
    pub fn set_dont_fragment(&mut self, value: bool) -> bool {
        self.field_5 = self.field_5& !(1<< 14) | ((if value {1} else {0} as u16) << 14);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn more_fragment(&self) -> bool {
        ((self.field_5>>13) & 1) as u8 != 0}
    pub fn set_more_fragment(&mut self, value: bool) -> bool {
        self.field_5 = self.field_5& !(1<< 13) | ((if value {1} else {0} as u16) << 13);
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn fragOffset(&self) -> u16 {
        ((self.field_5>>0) & 8191) as u16}
    pub fn set_fragOffset(&mut self, value: u16) -> bool {
        if value > 8191 {
        return false;
        }
        self.field_5 = self.field_5& !(8191<< 0) | ((value as u16) << 0);
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct CheckSum<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub sum: u32,
    pub has_prev: bool,
    pub prev: u8,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Header<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_3 :u8,/*version :4*/
    /*ihl :4*/
    
    
    field_4 :u8,/*dscp :6*/
    /*ecn :2*/
    
    
    pub len: u16,
    pub id: u16,
    field_5 :u16,/*reserved :1*/
    /*dont_fragment :1*/
    /*more_fragment :1*/
    /*fragOffset :13*/
    
    
    
    
    pub ttl: u8,
    pub proto: ProtocolNumber,
    pub checksum: u16,
    pub src_addr: [u8; 4],
    pub dst_addr: [u8; 4],
    pub options: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4PseudoHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub srcAddr: [u8; 4],
    pub dstAddr: [u8; 4],
    pub zero: u8,
    pub protocol: ProtocolNumber,
    pub length: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Packet<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hdr: IPv4Header<'a>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSum<'a>(data: std::borrow::Cow<'a,[u8]>) -> u16 {
    let mut sum = 0;
    let mut tmp52 = 0;
    while((tmp52 < (data.len() / 2))) {
        let mut i = tmp52;
        sum = (sum + ((((data)[(i * 2) as usize] as u32) << 8) | ((data)[((i * 2) + 1) as usize] as u32)));
        tmp52+= 1;
    }
    if ((data.len() % 2) == 1) {
        sum = (sum + (((data)[(data.len() - 1) as usize] as u32) << 8));
    }
    while((sum > 65535)) {
        sum = ((sum & 65535) + (sum >> 16));
    }
    return ((!sum) as u16);
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSumUpdate<'a>(s: CheckSum<'a>, data: std::borrow::Cow<'a,[u8]>) -> CheckSum<'a> {
    let mut p = s;
    let mut sum = p.sum;
    if (data.len() == 0) {
        return p;
    }
    if p.has_prev {
        sum = (sum + (((p.prev as u32) << 8) | ((data)[0 as usize] as u32)));
        let mut tmp123 = 0;
        while((tmp123 < ((data.len() - 1) / 2))) {
            let mut i = tmp123;
            sum = (sum + ((((data)[((i * 2) + 1) as usize] as u32) << 8) | ((data)[((i * 2) + 2) as usize] as u32)));
            tmp123+= 1;
        }
        if (((data.len() - 1) % 2) != 0) {
            p.prev = (data)[(data.len() - 1) as usize];
            p.has_prev = true;
        }
    } else {
        let mut tmp153 = 0;
        while((tmp153 < (data.len() / 2))) {
            let mut i = tmp153;
            sum = (sum + ((((data)[(i * 2) as usize] as u32) << 8) | ((data)[((i * 2) + 1) as usize] as u32)));
            tmp153+= 1;
        }
        if ((data.len() % 2) != 0) {
            p.prev = (data)[(data.len() - 1) as usize];
            p.has_prev = true;
        }
    }
    p.sum = sum;
    return p;
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSumFinish<'a>(s: CheckSum<'a>) -> u16 {
    let mut p = s;
    let mut sum = p.sum;
    if p.has_prev {
        sum = (sum + ((p.prev as u32) << 8));
    }
    while((sum > 65535)) {
        sum = ((sum & 65535) + (sum >> 16));
    }
    return ((!sum) as u16);
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp382 = <u8>::default();
        let mut tmp383 = 0;
        tmp383 = (tmp383 + 4);
        tmp382 = (tmp382 | (((self.version() as u8) & 15) << (8 - tmp383)));
        tmp383 = (tmp383 + 4);
        tmp382 = (tmp382 | (((self.ihl() as u8) & 15) << (8 - tmp383)));
        let mut tmp688 = <[u8; 1]>::default();
        (tmp688)[0 as usize] = tmp382;
        w.write_all(&tmp688[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_version_ihl",e))?;
        let mut tmp405 = <u8>::default();
        let mut tmp406 = 0;
        tmp406 = (tmp406 + 6);
        tmp405 = (tmp405 | (((self.dscp() as u8) & 63) << (8 - tmp406)));
        tmp406 = (tmp406 + 2);
        tmp405 = (tmp405 | (((self.ecn() as u8) & 3) << (8 - tmp406)));
        let mut tmp693 = <[u8; 1]>::default();
        (tmp693)[0 as usize] = tmp405;
        w.write_all(&tmp693[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_dscp_ecn",e))?;
        let mut tmp550 = <[u8; 2]>::default();
        let mut tmp551 = 0;
        while((tmp551 < 2)) {
            (tmp550)[tmp551 as usize] = (((self.len >> ((1 - tmp551) * 8)) & 255) as u8);
            tmp551+= 1;
        }
        w.write_all(&tmp550[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::len",e))?;
        let mut tmp563 = <[u8; 2]>::default();
        let mut tmp564 = 0;
        while((tmp564 < 2)) {
            (tmp563)[tmp564 as usize] = (((self.id >> ((1 - tmp564) * 8)) & 255) as u8);
            tmp564+= 1;
        }
        w.write_all(&tmp563[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::id",e))?;
        let mut tmp428 = <u16>::default();
        let mut tmp430 = 0;
        tmp430 = (tmp430 + 1);
        tmp428 = (tmp428 | ((if self.reserved() {1} else {0} & 1) << (16 - tmp430)));
        tmp430 = (tmp430 + 1);
        tmp428 = (tmp428 | ((if self.dont_fragment() {1} else {0} & 1) << (16 - tmp430)));
        tmp430 = (tmp430 + 1);
        tmp428 = (tmp428 | ((if self.more_fragment() {1} else {0} & 1) << (16 - tmp430)));
        tmp430 = (tmp430 + 13);
        tmp428 = (tmp428 | (((self.fragOffset() as u16) & 8191) << (16 - tmp430)));
        let mut tmp698 = <[u8; 2]>::default();
        let mut tmp699 = 0;
        while((tmp699 < 2)) {
            (tmp698)[tmp699 as usize] = (((tmp428 >> ((1 - tmp699) * 8)) & 255) as u8);
            tmp699+= 1;
        }
        w.write_all(&tmp698[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_reserved_dont_fragment_more_fragment_fragOffset",e))?;
        let mut tmp576 = <[u8; 1]>::default();
        (tmp576)[0 as usize] = self.ttl;
        w.write_all(&tmp576[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::ttl",e))?;
        let mut tmp581 = <[u8; 1]>::default();
        (tmp581)[0 as usize] = u8::from(self.proto);
        w.write_all(&tmp581[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::proto",e))?;
        let mut tmp586 = <[u8; 2]>::default();
        let mut tmp587 = 0;
        while((tmp587 < 2)) {
            (tmp586)[tmp587 as usize] = (((self.checksum >> ((1 - tmp587) * 8)) & 255) as u8);
            tmp587+= 1;
        }
        w.write_all(&tmp586[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::checksum",e))?;
        w.write_all(&self.src_addr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4Header::src_addr",e))?;
        w.write_all(&self.dst_addr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4Header::dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp216 = (((self.ihl() as u8) * 4) - 20);
        if self.options.len() != tmp216 as usize {
        return Err(Error::ArrayLengthMismatch("encode IPv4Header::options", tmp216 as usize, self.options.len()));
        }
        w.write_all(&self.options[0..self.options.len() as usize]).map_err(|e| Error::EncodeError("IPv4Header::options",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.hdr.encode(w)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp230 = len;
        if self.data.len() != tmp230 as usize {
        return Err(Error::ArrayLengthMismatch("encode IPv4Packet::data", tmp230 as usize, self.data.len()));
        }
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("IPv4Packet::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.srcAddr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::srcAddr",e))?;
        w.write_all(&self.dstAddr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::dstAddr",e))?;
        let mut tmp598 = <[u8; 1]>::default();
        (tmp598)[0 as usize] = self.zero;
        w.write_all(&tmp598[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::zero",e))?;
        let mut tmp603 = <[u8; 1]>::default();
        (tmp603)[0 as usize] = u8::from(self.protocol);
        w.write_all(&tmp603[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::protocol",e))?;
        let mut tmp608 = <[u8; 2]>::default();
        let mut tmp609 = 0;
        while((tmp609 < 2)) {
            (tmp608)[tmp609 as usize] = (((self.length >> ((1 - tmp609) * 8)) & 255) as u8);
            tmp609+= 1;
        }
        w.write_all(&tmp608[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::length",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp470 = <u8>::default();
        let mut tmp471 = 0;
        let mut tmp710 = <[u8; 1]>::default();
        r.read_exact(&mut tmp710[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_version_ihl",e))?;
        tmp470 = (tmp710)[0 as usize];
        tmp471 = (tmp471 + 4);
        self.set_version((((tmp470 >> (8 - tmp471)) & 15) as u8));
        tmp471 = (tmp471 + 4);
        self.set_ihl((((tmp470 >> (8 - tmp471)) & 15) as u8));
        let mut tmp491 = <u8>::default();
        let mut tmp492 = 0;
        let mut tmp715 = <[u8; 1]>::default();
        r.read_exact(&mut tmp715[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_dscp_ecn",e))?;
        tmp491 = (tmp715)[0 as usize];
        tmp492 = (tmp492 + 6);
        self.set_dscp((((tmp491 >> (8 - tmp492)) & 63) as u8));
        tmp492 = (tmp492 + 2);
        self.set_ecn((((tmp491 >> (8 - tmp492)) & 3) as u8));
        let mut tmp620 = <[u8; 2]>::default();
        r.read_exact(&mut tmp620[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::len",e))?;
        let mut tmp621 = 0;
        while((tmp621 < 2)) {
            self.len = (self.len | (((tmp620)[tmp621 as usize] as u16) << ((1 - tmp621) * 8)));
            tmp621+= 1;
        }
        let mut tmp632 = <[u8; 2]>::default();
        r.read_exact(&mut tmp632[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::id",e))?;
        let mut tmp633 = 0;
        while((tmp633 < 2)) {
            self.id = (self.id | (((tmp632)[tmp633 as usize] as u16) << ((1 - tmp633) * 8)));
            tmp633+= 1;
        }
        let mut tmp512 = <u16>::default();
        let mut tmp513 = 0;
        let mut tmp720 = <[u8; 2]>::default();
        r.read_exact(&mut tmp720[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_reserved_dont_fragment_more_fragment_fragOffset",e))?;
        let mut tmp721 = 0;
        while((tmp721 < 2)) {
            tmp512 = (tmp512 | (((tmp720)[tmp721 as usize] as u16) << ((1 - tmp721) * 8)));
            tmp721+= 1;
        }
        tmp513 = (tmp513 + 1);
        self.set_reserved(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 1);
        self.set_dont_fragment(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 1);
        self.set_more_fragment(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 13);
        self.set_fragOffset((((tmp512 >> (16 - tmp513)) & 8191) as u16));
        let mut tmp644 = <[u8; 1]>::default();
        r.read_exact(&mut tmp644[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::ttl",e))?;
        self.ttl = (tmp644)[0 as usize];
        let mut tmp238 = <u8>::default();
        let mut tmp649 = <[u8; 1]>::default();
        r.read_exact(&mut tmp649[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::proto",e))?;
        tmp238 = (tmp649)[0 as usize];
        self.proto = ProtocolNumber::from(tmp238);
        let mut tmp654 = <[u8; 2]>::default();
        r.read_exact(&mut tmp654[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::checksum",e))?;
        let mut tmp655 = 0;
        while((tmp655 < 2)) {
            self.checksum = (self.checksum | (((tmp654)[tmp655 as usize] as u16) << ((1 - tmp655) * 8)));
            tmp655+= 1;
        }
        r.read_exact(&mut self.src_addr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4Header::src_addr",e))?;
        r.read_exact(&mut self.dst_addr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4Header::dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp245 = (((self.ihl() as u8) * 4) - 20);
        self.options.to_mut().resize(tmp245 as usize,0);
        r.read_exact(self.options.to_mut()).map_err(|e| Error::DecodeError("IPv4Header::options",e))?;
        return Ok(());
    }
}
impl <'a>IPv4Header<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp470 = <u8>::default();
        let mut tmp471 = 0;
        let mut tmp710 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::bit_field_version_ihl",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp710.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp470 = (tmp710)[0 as usize];
        tmp471 = (tmp471 + 4);
        self.set_version((((tmp470 >> (8 - tmp471)) & 15) as u8));
        tmp471 = (tmp471 + 4);
        self.set_ihl((((tmp470 >> (8 - tmp471)) & 15) as u8));
        let mut tmp491 = <u8>::default();
        let mut tmp492 = 0;
        let mut tmp715 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::bit_field_dscp_ecn",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp715.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp491 = (tmp715)[0 as usize];
        tmp492 = (tmp492 + 6);
        self.set_dscp((((tmp491 >> (8 - tmp492)) & 63) as u8));
        tmp492 = (tmp492 + 2);
        self.set_ecn((((tmp491 >> (8 - tmp492)) & 3) as u8));
        let mut tmp620 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::len",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp620.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp621 = 0;
        while((tmp621 < 2)) {
            self.len = (self.len | (((tmp620)[tmp621 as usize] as u16) << ((1 - tmp621) * 8)));
            tmp621+= 1;
        }
        let mut tmp632 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::id",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp632.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp633 = 0;
        while((tmp633 < 2)) {
            self.id = (self.id | (((tmp632)[tmp633 as usize] as u16) << ((1 - tmp633) * 8)));
            tmp633+= 1;
        }
        let mut tmp512 = <u16>::default();
        let mut tmp513 = 0;
        let mut tmp720 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::bit_field_reserved_dont_fragment_more_fragment_fragOffset",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp720.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp721 = 0;
        while((tmp721 < 2)) {
            tmp512 = (tmp512 | (((tmp720)[tmp721 as usize] as u16) << ((1 - tmp721) * 8)));
            tmp721+= 1;
        }
        tmp513 = (tmp513 + 1);
        self.set_reserved(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 1);
        self.set_dont_fragment(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 1);
        self.set_more_fragment(((tmp512 >> (16 - tmp513)) & 1) != 0);
        tmp513 = (tmp513 + 13);
        self.set_fragOffset((((tmp512 >> (16 - tmp513)) & 8191) as u16));
        let mut tmp644 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::ttl",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp644.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        self.ttl = (tmp644)[0 as usize];
        let mut tmp238 = <u8>::default();
        let mut tmp649 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::proto",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp649.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp238 = (tmp649)[0 as usize];
        self.proto = ProtocolNumber::from(tmp238);
        let mut tmp654 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::checksum",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp654.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp655 = 0;
        while((tmp655 < 2)) {
            self.checksum = (self.checksum | (((tmp654)[tmp655 as usize] as u16) << ((1 - tmp655) * 8)));
            tmp655+= 1;
        }
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::src_addr",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.src_addr.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::dst_addr",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.dst_addr.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp245 = (((self.ihl() as u8) * 4) - 20);
        if *offset + (tmp245 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Header::options",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.options = std::borrow::Cow::Borrowed(&r[*offset..(*offset + (tmp245 as usize as usize))]);
        *offset += (tmp245 as usize as usize);
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.hdr.decode(r)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp257 = len;
        self.data.to_mut().resize(tmp257 as usize,0);
        r.read_exact(self.data.to_mut()).map_err(|e| Error::DecodeError("IPv4Packet::data",e))?;
        return Ok(());
    }
}
impl <'a>IPv4Packet<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        self.hdr.decode_direct(r, offset)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp257 = len;
        if *offset + (tmp257 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4Packet::data",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.data = std::borrow::Cow::Borrowed(&r[*offset..(*offset + (tmp257 as usize as usize))]);
        *offset += (tmp257 as usize as usize);
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.srcAddr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::srcAddr",e))?;
        r.read_exact(&mut self.dstAddr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::dstAddr",e))?;
        let mut tmp666 = <[u8; 1]>::default();
        r.read_exact(&mut tmp666[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::zero",e))?;
        self.zero = (tmp666)[0 as usize];
        let mut tmp260 = <u8>::default();
        let mut tmp671 = <[u8; 1]>::default();
        r.read_exact(&mut tmp671[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::protocol",e))?;
        tmp260 = (tmp671)[0 as usize];
        self.protocol = ProtocolNumber::from(tmp260);
        let mut tmp676 = <[u8; 2]>::default();
        r.read_exact(&mut tmp676[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::length",e))?;
        let mut tmp677 = 0;
        while((tmp677 < 2)) {
            self.length = (self.length | (((tmp676)[tmp677 as usize] as u16) << ((1 - tmp677) * 8)));
            tmp677+= 1;
        }
        return Ok(());
    }
}
impl <'a>IPv4PseudoHeader<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4PseudoHeader::srcAddr",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.srcAddr.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4PseudoHeader::dstAddr",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.dstAddr.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp666 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4PseudoHeader::zero",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp666.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        self.zero = (tmp666)[0 as usize];
        let mut tmp260 = <u8>::default();
        let mut tmp671 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4PseudoHeader::protocol",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp671.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp260 = (tmp671)[0 as usize];
        self.protocol = ProtocolNumber::from(tmp260);
        let mut tmp676 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("IPv4PseudoHeader::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp676.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp677 = 0;
        while((tmp677 < 2)) {
            self.length = (self.length | (((tmp676)[tmp677 as usize] as u16) << ((1 - tmp677) * 8)));
            tmp677+= 1;
        }
        return Ok(());
    }
}

// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum ProtocolNumber {
    #[default]
    ICMP = 1,
    TCP = 6,
    UDP = 17,
}
impl std::fmt::Display for ProtocolNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u8 {
            1 => write!(f, "{}", "ICMP"),
            6 => write!(f, "{}", "TCP"),
            17 => write!(f, "{}", "UDP"),
            _ => write!(f, "ProtocolNumber({})",*self as u8),
        }
    }
}
impl ProtocolNumber {
    pub fn is_known(&self) -> bool {
        match *self as u8 {
            1 => true,
            6 => true,
            17 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for ProtocolNumber {
    fn from(e: u8) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<ProtocolNumber> for u8 {
    fn from(e: ProtocolNumber) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_STATE */
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl <'a>IPv4Header<'a> {
    pub fn version(&self) -> u8 {
        ((self.field_3>>4) & 15) as u8}
    pub fn set_version(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 |= (value as u8) << 4;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ihl(&self) -> u8 {
        ((self.field_3>>0) & 15) as u8}
    pub fn set_ihl(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 |= (value as u8) << 0;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dscp(&self) -> u8 {
        ((self.field_4>>2) & 63) as u8}
    pub fn set_dscp(&mut self, value: u8) -> bool {
        if value > 63 {
        return false;
        }
        self.field_4 |= (value as u8) << 2;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ecn(&self) -> u8 {
        ((self.field_4>>0) & 3) as u8}
    pub fn set_ecn(&mut self, value: u8) -> bool {
        if value > 3 {
        return false;
        }
        self.field_4 |= (value as u8) << 0;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn reserved(&self) -> bool {
        ((self.field_5>>15) & 1) as u8 != 0}
    pub fn set_reserved(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 15;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dont_fragment(&self) -> bool {
        ((self.field_5>>14) & 1) as u8 != 0}
    pub fn set_dont_fragment(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 14;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn more_fragment(&self) -> bool {
        ((self.field_5>>13) & 1) as u8 != 0}
    pub fn set_more_fragment(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 13;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn fragOffset(&self) -> u16 {
        ((self.field_5>>0) & 8191) as u16}
    pub fn set_fragOffset(&mut self, value: u16) -> bool {
        if value > 8191 {
        return false;
        }
        self.field_5 |= (value as u16) << 0;
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct CheckSum<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub sum: u32,
    pub has_prev: bool,
    pub prev: u8,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Header<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_3 :u8,/*version :4*/
    /*ihl :4*/
    
    
    field_4 :u8,/*dscp :6*/
    /*ecn :2*/
    
    
    pub len: u16,
    pub id: u16,
    field_5 :u16,/*reserved :1*/
    /*dont_fragment :1*/
    /*more_fragment :1*/
    /*fragOffset :13*/
    
    
    
    
    pub ttl: u8,
    pub proto: ProtocolNumber,
    pub checksum: u16,
    pub src_addr: [u8; 4],
    pub dst_addr: [u8; 4],
    pub options: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4PseudoHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub srcAddr: [u8; 4],
    pub dstAddr: [u8; 4],
    pub zero: u8,
    pub protocol: ProtocolNumber,
    pub length: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Packet<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hdr: IPv4Header<'a>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSum<'a>(data: std::borrow::Cow<'a,[u8]>) -> u16 {
    let mut sum = 0;
    let mut tmp52 = 0;
    while((tmp52 < (data.len() / 2))) {
        let mut i = tmp52;
        sum = (sum + ((((data)[(i * 2) as usize] as u32) << 8) | ((data)[((i * 2) + 1) as usize] as u32)));
        tmp52+= 1;
    }
    if ((data.len() % 2) == 1) {
        sum = (sum + (((data)[(data.len() - 1) as usize] as u32) << 8));
    }
    while((sum > 65535)) {
        sum = ((sum & 65535) + (sum >> 16));
    }
    return ((!sum) as u16);
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSumUpdate<'a>(s: CheckSum<'a>, data: std::borrow::Cow<'a,[u8]>) -> CheckSum<'a> {
    let mut p = s;
    let mut sum = p.sum;
    if (data.len() == 0) {
        return p;
    }
    if p.has_prev {
        sum = (sum + (((p.prev as u32) << 8) | ((data)[0 as usize] as u32)));
        let mut tmp123 = 0;
        while((tmp123 < ((data.len() - 1) / 2))) {
            let mut i = tmp123;
            sum = (sum + ((((data)[((i * 2) + 1) as usize] as u32) << 8) | ((data)[((i * 2) + 2) as usize] as u32)));
            tmp123+= 1;
        }
        if (((data.len() - 1) % 2) != 0) {
            p.prev = (data)[(data.len() - 1) as usize];
            p.has_prev = true;
        }
    } else {
        let mut tmp153 = 0;
        while((tmp153 < (data.len() / 2))) {
            let mut i = tmp153;
            sum = (sum + ((((data)[(i * 2) as usize] as u32) << 8) | ((data)[((i * 2) + 1) as usize] as u32)));
            tmp153+= 1;
        }
        if ((data.len() % 2) != 0) {
            p.prev = (data)[(data.len() - 1) as usize];
            p.has_prev = true;
        }
    }
    return p;
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSumFinish<'a>(s: CheckSum<'a>) -> u16 {
    let mut p = s;
    let mut sum = p.sum;
    if p.has_prev {
        sum = (sum + ((p.prev as u32) << 8));
    }
    while((sum > 65535)) {
        sum = ((sum & 65535) + (sum >> 16));
    }
    return ((!sum) as u16);
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp380 = <u8>::default();
        let mut tmp381 = 0;
        tmp381 = (tmp381 + 4);
        tmp380 = (tmp380 | (((self.version() as u8) & 15) << (8 - tmp381)));
        tmp381 = (tmp381 + 4);
        tmp380 = (tmp380 | (((self.ihl() as u8) & 15) << (8 - tmp381)));
        let mut tmp686 = <[u8; 1]>::default();
        (tmp686)[0 as usize] = tmp380;
        w.write_all(&tmp686[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_version_ihl",e))?;
        let mut tmp403 = <u8>::default();
        let mut tmp404 = 0;
        tmp404 = (tmp404 + 6);
        tmp403 = (tmp403 | (((self.dscp() as u8) & 63) << (8 - tmp404)));
        tmp404 = (tmp404 + 2);
        tmp403 = (tmp403 | (((self.ecn() as u8) & 3) << (8 - tmp404)));
        let mut tmp691 = <[u8; 1]>::default();
        (tmp691)[0 as usize] = tmp403;
        w.write_all(&tmp691[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_dscp_ecn",e))?;
        let mut tmp548 = <[u8; 2]>::default();
        let mut tmp549 = 0;
        while((tmp549 < 2)) {
            (tmp548)[tmp549 as usize] = (((self.len >> ((1 - tmp549) * 8)) & 255) as u8);
            tmp549+= 1;
        }
        w.write_all(&tmp548[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::len",e))?;
        let mut tmp561 = <[u8; 2]>::default();
        let mut tmp562 = 0;
        while((tmp562 < 2)) {
            (tmp561)[tmp562 as usize] = (((self.id >> ((1 - tmp562) * 8)) & 255) as u8);
            tmp562+= 1;
        }
        w.write_all(&tmp561[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::id",e))?;
        let mut tmp426 = <u16>::default();
        let mut tmp428 = 0;
        tmp428 = (tmp428 + 1);
        tmp426 = (tmp426 | ((if self.reserved() {1} else {0} & 1) << (16 - tmp428)));
        tmp428 = (tmp428 + 1);
        tmp426 = (tmp426 | ((if self.dont_fragment() {1} else {0} & 1) << (16 - tmp428)));
        tmp428 = (tmp428 + 1);
        tmp426 = (tmp426 | ((if self.more_fragment() {1} else {0} & 1) << (16 - tmp428)));
        tmp428 = (tmp428 + 13);
        tmp426 = (tmp426 | (((self.fragOffset() as u16) & 8191) << (16 - tmp428)));
        let mut tmp696 = <[u8; 2]>::default();
        let mut tmp697 = 0;
        while((tmp697 < 2)) {
            (tmp696)[tmp697 as usize] = (((tmp426 >> ((1 - tmp697) * 8)) & 255) as u8);
            tmp697+= 1;
        }
        w.write_all(&tmp696[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::bit_field_reserved_dont_fragment_more_fragment_fragOffset",e))?;
        let mut tmp574 = <[u8; 1]>::default();
        (tmp574)[0 as usize] = self.ttl;
        w.write_all(&tmp574[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::ttl",e))?;
        let mut tmp579 = <[u8; 1]>::default();
        (tmp579)[0 as usize] = u8::from(self.proto);
        w.write_all(&tmp579[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4Header::proto",e))?;
        let mut tmp584 = <[u8; 2]>::default();
        let mut tmp585 = 0;
        while((tmp585 < 2)) {
            (tmp584)[tmp585 as usize] = (((self.checksum >> ((1 - tmp585) * 8)) & 255) as u8);
            tmp585+= 1;
        }
        w.write_all(&tmp584[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4Header::checksum",e))?;
        w.write_all(&self.src_addr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4Header::src_addr",e))?;
        w.write_all(&self.dst_addr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4Header::dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp214 = (((self.ihl() as u8) * 4) - 20);
        if self.options.len() != tmp214 as usize {
        return Err(Error::ArrayLengthMismatch("encode IPv4Header::options", tmp214 as usize, self.options.len()));
        }
        w.write_all(&self.options[0..self.options.len() as usize]).map_err(|e| Error::EncodeError("IPv4Header::options",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.hdr.encode(w)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp228 = len;
        if self.data.len() != tmp228 as usize {
        return Err(Error::ArrayLengthMismatch("encode IPv4Packet::data", tmp228 as usize, self.data.len()));
        }
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("IPv4Packet::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.srcAddr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::srcAddr",e))?;
        w.write_all(&self.dstAddr[0..4 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::dstAddr",e))?;
        let mut tmp596 = <[u8; 1]>::default();
        (tmp596)[0 as usize] = self.zero;
        w.write_all(&tmp596[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::zero",e))?;
        let mut tmp601 = <[u8; 1]>::default();
        (tmp601)[0 as usize] = u8::from(self.protocol);
        w.write_all(&tmp601[0..1 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::protocol",e))?;
        let mut tmp606 = <[u8; 2]>::default();
        let mut tmp607 = 0;
        while((tmp607 < 2)) {
            (tmp606)[tmp607 as usize] = (((self.length >> ((1 - tmp607) * 8)) & 255) as u8);
            tmp607+= 1;
        }
        w.write_all(&tmp606[0..2 as usize]).map_err(|e| Error::EncodeError("IPv4PseudoHeader::length",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp468 = <u8>::default();
        let mut tmp469 = 0;
        let mut tmp708 = <[u8; 1]>::default();
        r.read_exact(&mut tmp708[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_version_ihl",e))?;
        tmp468 = (tmp708)[0 as usize];
        tmp469 = (tmp469 + 4);
        self.set_version((((tmp468 >> (8 - tmp469)) & 15) as u8));
        tmp469 = (tmp469 + 4);
        self.set_ihl((((tmp468 >> (8 - tmp469)) & 15) as u8));
        let mut tmp489 = <u8>::default();
        let mut tmp490 = 0;
        let mut tmp713 = <[u8; 1]>::default();
        r.read_exact(&mut tmp713[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_dscp_ecn",e))?;
        tmp489 = (tmp713)[0 as usize];
        tmp490 = (tmp490 + 6);
        self.set_dscp((((tmp489 >> (8 - tmp490)) & 63) as u8));
        tmp490 = (tmp490 + 2);
        self.set_ecn((((tmp489 >> (8 - tmp490)) & 3) as u8));
        let mut tmp618 = <[u8; 2]>::default();
        r.read_exact(&mut tmp618[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::len",e))?;
        let mut tmp619 = 0;
        while((tmp619 < 2)) {
            self.len = (self.len | (((tmp618)[tmp619 as usize] as u16) << ((1 - tmp619) * 8)));
            tmp619+= 1;
        }
        let mut tmp630 = <[u8; 2]>::default();
        r.read_exact(&mut tmp630[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::id",e))?;
        let mut tmp631 = 0;
        while((tmp631 < 2)) {
            self.id = (self.id | (((tmp630)[tmp631 as usize] as u16) << ((1 - tmp631) * 8)));
            tmp631+= 1;
        }
        let mut tmp510 = <u16>::default();
        let mut tmp511 = 0;
        let mut tmp718 = <[u8; 2]>::default();
        r.read_exact(&mut tmp718[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::bit_field_reserved_dont_fragment_more_fragment_fragOffset",e))?;
        let mut tmp719 = 0;
        while((tmp719 < 2)) {
            tmp510 = (tmp510 | (((tmp718)[tmp719 as usize] as u16) << ((1 - tmp719) * 8)));
            tmp719+= 1;
        }
        tmp511 = (tmp511 + 1);
        self.set_reserved(((tmp510 >> (16 - tmp511)) & 1) != 0);
        tmp511 = (tmp511 + 1);
        self.set_dont_fragment(((tmp510 >> (16 - tmp511)) & 1) != 0);
        tmp511 = (tmp511 + 1);
        self.set_more_fragment(((tmp510 >> (16 - tmp511)) & 1) != 0);
        tmp511 = (tmp511 + 13);
        self.set_fragOffset((((tmp510 >> (16 - tmp511)) & 8191) as u16));
        let mut tmp642 = <[u8; 1]>::default();
        r.read_exact(&mut tmp642[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::ttl",e))?;
        self.ttl = (tmp642)[0 as usize];
        let mut tmp236 = <u8>::default();
        let mut tmp647 = <[u8; 1]>::default();
        r.read_exact(&mut tmp647[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4Header::proto",e))?;
        tmp236 = (tmp647)[0 as usize];
        self.proto = ProtocolNumber::from(tmp236);
        let mut tmp652 = <[u8; 2]>::default();
        r.read_exact(&mut tmp652[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4Header::checksum",e))?;
        let mut tmp653 = 0;
        while((tmp653 < 2)) {
            self.checksum = (self.checksum | (((tmp652)[tmp653 as usize] as u16) << ((1 - tmp653) * 8)));
            tmp653+= 1;
        }
        r.read_exact(&mut self.src_addr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4Header::src_addr",e))?;
        r.read_exact(&mut self.dst_addr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4Header::dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp243 = (((self.ihl() as u8) * 4) - 20);
        self.options.to_mut().resize(tmp243 as usize,0);
        r.read_exact(self.options.to_mut()).map_err(|e| Error::DecodeError("IPv4Header::options",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.hdr.decode(r)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp255 = len;
        self.data.to_mut().resize(tmp255 as usize,0);
        r.read_exact(self.data.to_mut()).map_err(|e| Error::DecodeError("IPv4Packet::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.srcAddr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::srcAddr",e))?;
        r.read_exact(&mut self.dstAddr[0..4 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::dstAddr",e))?;
        let mut tmp664 = <[u8; 1]>::default();
        r.read_exact(&mut tmp664[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::zero",e))?;
        self.zero = (tmp664)[0 as usize];
        let mut tmp258 = <u8>::default();
        let mut tmp669 = <[u8; 1]>::default();
        r.read_exact(&mut tmp669[0..1 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::protocol",e))?;
        tmp258 = (tmp669)[0 as usize];
        self.protocol = ProtocolNumber::from(tmp258);
        let mut tmp674 = <[u8; 2]>::default();
        r.read_exact(&mut tmp674[0..2 as usize]).map_err(|e| Error::DecodeError("IPv4PseudoHeader::length",e))?;
        let mut tmp675 = 0;
        while((tmp675 < 2)) {
            self.length = (self.length | (((tmp674)[tmp675 as usize] as u16) << ((1 - tmp675) * 8)));
            tmp675+= 1;
        }
        return Ok(());
    }
}

// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    IOError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::IOError(s,e) => write!(f, "IOError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::IOError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum ProtocolNumber {
    #[default]
    ICMP = 1,
    TCP = 6,
    UDP = 17,
}
impl std::fmt::Display for ProtocolNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u8 {
            1 => write!(f, "{}", "ICMP"),
            6 => write!(f, "{}", "TCP"),
            17 => write!(f, "{}", "UDP"),
            _ => write!(f, "ProtocolNumber({})",*self as u8),
        }
    }
}
impl ProtocolNumber {
    pub fn is_known(&self) -> bool {
        match *self as u8 {
            1 => true,
            6 => true,
            17 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for ProtocolNumber {
    fn from(e: u8) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<ProtocolNumber> for u8 {
    fn from(e: ProtocolNumber) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FUNCTION */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl <'a>IPv4Header<'a> {
    pub fn version(&self) -> u8 {
        ((self.field_3>>4) & 15) as u8}
    pub fn set_version(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 |= (value as u8) << 4;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ihl(&self) -> u8 {
        ((self.field_3>>0) & 15) as u8}
    pub fn set_ihl(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_3 |= (value as u8) << 0;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dscp(&self) -> u8 {
        ((self.field_4>>2) & 63) as u8}
    pub fn set_dscp(&mut self, value: u8) -> bool {
        if value > 63 {
        return false;
        }
        self.field_4 |= (value as u8) << 2;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn ecn(&self) -> u8 {
        ((self.field_4>>0) & 3) as u8}
    pub fn set_ecn(&mut self, value: u8) -> bool {
        if value > 3 {
        return false;
        }
        self.field_4 |= (value as u8) << 0;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn reserved(&self) -> bool {
        ((self.field_5>>15) & 1) as u8 != 0}
    pub fn set_reserved(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 15;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn dont_fragment(&self) -> bool {
        ((self.field_5>>14) & 1) as u8 != 0}
    pub fn set_dont_fragment(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 14;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn more_fragment(&self) -> bool {
        ((self.field_5>>13) & 1) as u8 != 0}
    pub fn set_more_fragment(&mut self, value: bool) -> bool {
        self.field_5 |= (if value {1} else {0} as u16) << 13;
        true
    }
}
impl <'a>IPv4Header<'a> {
    pub fn fragOffset(&self) -> u16 {
        ((self.field_5>>0) & 8191) as u16}
    pub fn set_fragOffset(&mut self, value: u16) -> bool {
        if value > 8191 {
        return false;
        }
        self.field_5 |= (value as u16) << 0;
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Header<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_3 :u8,/*version :4*/
    /*ihl :4*/
    
    
    field_4 :u8,/*dscp :6*/
    /*ecn :2*/
    
    
    pub len: u16,
    pub id: u16,
    field_5 :u16,/*reserved :1*/
    /*dont_fragment :1*/
    /*more_fragment :1*/
    /*fragOffset :13*/
    
    
    
    
    pub ttl: u8,
    pub proto: ProtocolNumber,
    pub checksum: u16,
    pub src_addr: [u8; 4],
    pub dst_addr: [u8; 4],
    pub options: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4PseudoHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub srcAddr: [u8; 4],
    pub dstAddr: [u8; 4],
    pub zero: u8,
    pub protocol: ProtocolNumber,
    pub length: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct IPv4Packet<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hdr: IPv4Header<'a>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
pub fn checkSum<'a>(data: std::borrow::Cow<'a,[u8]>) -> u16 {
    let mut sum = 0;
    let mut tmp52 = 0;
    while((tmp52 < (data.len() / 2))) {
        let mut i = tmp52;
        sum = (sum + ((((data)[(i * 2) as usize] as u32) << 8) | ((data)[((i * 2) + 1) as usize] as u32)));
        tmp52+= 1;
    }
    if ((data.len() % 2) == 1) {
        sum = (sum + (((data)[(data.len() - 1) as usize] as u32) << 8));
    }
    while((sum > 65535)) {
        sum = ((sum & 65535) + (sum >> 16));
    }
    return ((!sum) as u16);
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp275 = <u8>::default();
        let mut tmp276 = 0;
        tmp276 = (tmp276 + 4);
        tmp275 = (tmp275 | (((self.version() as u8) & 15) << (8 - tmp276)));
        tmp276 = (tmp276 + 4);
        tmp275 = (tmp275 | (((self.ihl() as u8) & 15) << (8 - tmp276)));
        let mut tmp581 = <[u8; 1]>::default();
        (tmp581)[0 as usize] = tmp275;
        w.write_all(&tmp581[0..1 as usize]).map_err(|e| Error::IOError("self",e))?;
        let mut tmp298 = <u8>::default();
        let mut tmp299 = 0;
        tmp299 = (tmp299 + 6);
        tmp298 = (tmp298 | (((self.dscp() as u8) & 63) << (8 - tmp299)));
        tmp299 = (tmp299 + 2);
        tmp298 = (tmp298 | (((self.ecn() as u8) & 3) << (8 - tmp299)));
        let mut tmp586 = <[u8; 1]>::default();
        (tmp586)[0 as usize] = tmp298;
        w.write_all(&tmp586[0..1 as usize]).map_err(|e| Error::IOError("self",e))?;
        let mut tmp443 = <[u8; 2]>::default();
        let mut tmp444 = 0;
        while((tmp444 < 2)) {
            (tmp443)[tmp444 as usize] = (((self.len >> ((1 - tmp444) * 8)) & 255) as u8);
            tmp444+= 1;
        }
        w.write_all(&tmp443[0..2 as usize]).map_err(|e| Error::IOError("self.len",e))?;
        let mut tmp456 = <[u8; 2]>::default();
        let mut tmp457 = 0;
        while((tmp457 < 2)) {
            (tmp456)[tmp457 as usize] = (((self.id >> ((1 - tmp457) * 8)) & 255) as u8);
            tmp457+= 1;
        }
        w.write_all(&tmp456[0..2 as usize]).map_err(|e| Error::IOError("self.id",e))?;
        let mut tmp321 = <u16>::default();
        let mut tmp323 = 0;
        tmp323 = (tmp323 + 1);
        tmp321 = (tmp321 | ((if self.reserved() {1} else {0} & 1) << (16 - tmp323)));
        tmp323 = (tmp323 + 1);
        tmp321 = (tmp321 | ((if self.dont_fragment() {1} else {0} & 1) << (16 - tmp323)));
        tmp323 = (tmp323 + 1);
        tmp321 = (tmp321 | ((if self.more_fragment() {1} else {0} & 1) << (16 - tmp323)));
        tmp323 = (tmp323 + 13);
        tmp321 = (tmp321 | (((self.fragOffset() as u16) & 8191) << (16 - tmp323)));
        let mut tmp591 = <[u8; 2]>::default();
        let mut tmp592 = 0;
        while((tmp592 < 2)) {
            (tmp591)[tmp592 as usize] = (((tmp321 >> ((1 - tmp592) * 8)) & 255) as u8);
            tmp592+= 1;
        }
        w.write_all(&tmp591[0..2 as usize]).map_err(|e| Error::IOError("self",e))?;
        let mut tmp469 = <[u8; 1]>::default();
        (tmp469)[0 as usize] = self.ttl;
        w.write_all(&tmp469[0..1 as usize]).map_err(|e| Error::IOError("self.ttl",e))?;
        let mut tmp474 = <[u8; 1]>::default();
        (tmp474)[0 as usize] = u8::from(self.proto);
        w.write_all(&tmp474[0..1 as usize]).map_err(|e| Error::IOError("self.proto",e))?;
        let mut tmp479 = <[u8; 2]>::default();
        let mut tmp480 = 0;
        while((tmp480 < 2)) {
            (tmp479)[tmp480 as usize] = (((self.checksum >> ((1 - tmp480) * 8)) & 255) as u8);
            tmp480+= 1;
        }
        w.write_all(&tmp479[0..2 as usize]).map_err(|e| Error::IOError("self.checksum",e))?;
        w.write_all(&self.src_addr[0..4 as usize]).map_err(|e| Error::IOError("self.src_addr",e))?;
        w.write_all(&self.dst_addr[0..4 as usize]).map_err(|e| Error::IOError("self.dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp109 = (((self.ihl() as u8) * 4) - 20);
        if self.options.len() != tmp109 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.options", tmp109 as usize, self.options.len()));
        }
        w.write_all(&self.options[0..self.options.len() as usize]).map_err(|e| Error::IOError("self.options",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.hdr.encode(w)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp123 = len;
        if self.data.len() != tmp123 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.data", tmp123 as usize, self.data.len()));
        }
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::IOError("self.data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.srcAddr[0..4 as usize]).map_err(|e| Error::IOError("self.srcAddr",e))?;
        w.write_all(&self.dstAddr[0..4 as usize]).map_err(|e| Error::IOError("self.dstAddr",e))?;
        let mut tmp491 = <[u8; 1]>::default();
        (tmp491)[0 as usize] = self.zero;
        w.write_all(&tmp491[0..1 as usize]).map_err(|e| Error::IOError("self.zero",e))?;
        let mut tmp496 = <[u8; 1]>::default();
        (tmp496)[0 as usize] = u8::from(self.protocol);
        w.write_all(&tmp496[0..1 as usize]).map_err(|e| Error::IOError("self.protocol",e))?;
        let mut tmp501 = <[u8; 2]>::default();
        let mut tmp502 = 0;
        while((tmp502 < 2)) {
            (tmp501)[tmp502 as usize] = (((self.length >> ((1 - tmp502) * 8)) & 255) as u8);
            tmp502+= 1;
        }
        w.write_all(&tmp501[0..2 as usize]).map_err(|e| Error::IOError("self.length",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4Header<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp363 = <u8>::default();
        let mut tmp364 = 0;
        let mut tmp603 = <[u8; 1]>::default();
        r.read_exact(&mut tmp603[0..1 as usize]).map_err(|e| Error::IOError("self",e))?;
        tmp363 = (tmp603)[0 as usize];
        tmp364 = (tmp364 + 4);
        self.set_version((((tmp363 >> (8 - tmp364)) & 15) as u8));
        tmp364 = (tmp364 + 4);
        self.set_ihl((((tmp363 >> (8 - tmp364)) & 15) as u8));
        let mut tmp384 = <u8>::default();
        let mut tmp385 = 0;
        let mut tmp608 = <[u8; 1]>::default();
        r.read_exact(&mut tmp608[0..1 as usize]).map_err(|e| Error::IOError("self",e))?;
        tmp384 = (tmp608)[0 as usize];
        tmp385 = (tmp385 + 6);
        self.set_dscp((((tmp384 >> (8 - tmp385)) & 63) as u8));
        tmp385 = (tmp385 + 2);
        self.set_ecn((((tmp384 >> (8 - tmp385)) & 3) as u8));
        let mut tmp513 = <[u8; 2]>::default();
        r.read_exact(&mut tmp513[0..2 as usize]).map_err(|e| Error::IOError("self.len",e))?;
        let mut tmp514 = 0;
        while((tmp514 < 2)) {
            self.len = (self.len | (((tmp513)[tmp514 as usize] as u16) << ((1 - tmp514) * 8)));
            tmp514+= 1;
        }
        let mut tmp525 = <[u8; 2]>::default();
        r.read_exact(&mut tmp525[0..2 as usize]).map_err(|e| Error::IOError("self.id",e))?;
        let mut tmp526 = 0;
        while((tmp526 < 2)) {
            self.id = (self.id | (((tmp525)[tmp526 as usize] as u16) << ((1 - tmp526) * 8)));
            tmp526+= 1;
        }
        let mut tmp405 = <u16>::default();
        let mut tmp406 = 0;
        let mut tmp613 = <[u8; 2]>::default();
        r.read_exact(&mut tmp613[0..2 as usize]).map_err(|e| Error::IOError("self",e))?;
        let mut tmp614 = 0;
        while((tmp614 < 2)) {
            tmp405 = (tmp405 | (((tmp613)[tmp614 as usize] as u16) << ((1 - tmp614) * 8)));
            tmp614+= 1;
        }
        tmp406 = (tmp406 + 1);
        self.set_reserved(((tmp405 >> (16 - tmp406)) & 1) != 0);
        tmp406 = (tmp406 + 1);
        self.set_dont_fragment(((tmp405 >> (16 - tmp406)) & 1) != 0);
        tmp406 = (tmp406 + 1);
        self.set_more_fragment(((tmp405 >> (16 - tmp406)) & 1) != 0);
        tmp406 = (tmp406 + 13);
        self.set_fragOffset((((tmp405 >> (16 - tmp406)) & 8191) as u16));
        let mut tmp537 = <[u8; 1]>::default();
        r.read_exact(&mut tmp537[0..1 as usize]).map_err(|e| Error::IOError("self.ttl",e))?;
        self.ttl = (tmp537)[0 as usize];
        let mut tmp131 = <u8>::default();
        let mut tmp542 = <[u8; 1]>::default();
        r.read_exact(&mut tmp542[0..1 as usize]).map_err(|e| Error::IOError("self.proto",e))?;
        tmp131 = (tmp542)[0 as usize];
        self.proto = ProtocolNumber::from(tmp131);
        let mut tmp547 = <[u8; 2]>::default();
        r.read_exact(&mut tmp547[0..2 as usize]).map_err(|e| Error::IOError("self.checksum",e))?;
        let mut tmp548 = 0;
        while((tmp548 < 2)) {
            self.checksum = (self.checksum | (((tmp547)[tmp548 as usize] as u16) << ((1 - tmp548) * 8)));
            tmp548+= 1;
        }
        r.read_exact(&mut self.src_addr[0..4 as usize]).map_err(|e| Error::IOError("self.src_addr",e))?;
        r.read_exact(&mut self.dst_addr[0..4 as usize]).map_err(|e| Error::IOError("self.dst_addr",e))?;
        if(!(self.ihl() >= 5)) { 
        return Err(Error::AssertError("(self.ihl() >= 5)"));
        }
        let mut tmp138 = (((self.ihl() as u8) * 4) - 20);
        self.options.to_mut().resize(tmp138 as usize,0);
        r.read_exact(self.options.to_mut()).map_err(|e| Error::IOError("self.options",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>IPv4Packet<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.hdr.decode(r)?;
        if(!(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))) { 
        return Err(Error::AssertError("(self.hdr.len >= ((self.hdr.ihl() as u16) * 4))"));
        }
        let mut len = (self.hdr.len - ((self.hdr.ihl() * 4) as u16));
        let mut tmp150 = len;
        self.data.to_mut().resize(tmp150 as usize,0);
        r.read_exact(self.data.to_mut()).map_err(|e| Error::IOError("self.data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>IPv4PseudoHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.srcAddr[0..4 as usize]).map_err(|e| Error::IOError("self.srcAddr",e))?;
        r.read_exact(&mut self.dstAddr[0..4 as usize]).map_err(|e| Error::IOError("self.dstAddr",e))?;
        let mut tmp559 = <[u8; 1]>::default();
        r.read_exact(&mut tmp559[0..1 as usize]).map_err(|e| Error::IOError("self.zero",e))?;
        self.zero = (tmp559)[0 as usize];
        let mut tmp153 = <u8>::default();
        let mut tmp564 = <[u8; 1]>::default();
        r.read_exact(&mut tmp564[0..1 as usize]).map_err(|e| Error::IOError("self.protocol",e))?;
        tmp153 = (tmp564)[0 as usize];
        self.protocol = ProtocolNumber::from(tmp153);
        let mut tmp569 = <[u8; 2]>::default();
        r.read_exact(&mut tmp569[0..2 as usize]).map_err(|e| Error::IOError("self.length",e))?;
        let mut tmp570 = 0;
        while((tmp570 < 2)) {
            self.length = (self.length | (((tmp569)[tmp570 as usize] as u16) << ((1 - tmp570) * 8)));
            tmp570+= 1;
        }
        return Ok(());
    }
}

// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct MessageType(u16);
impl MessageType  {
    pub const BindingRequest:Self = Self(1);
    pub const BindingResponse:Self = Self(257);
    pub const BindingErrorResponse:Self = Self(273);
    pub const SharedSecretRequest:Self = Self(2);
    pub const SharedSecretResponse:Self = Self(258);
    pub const SharedSecretErrorResponse:Self = Self(274);
}
impl std::fmt::Display for MessageType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MessageType::BindingRequest => write!(f, "{}", "BindingRequest"),
            MessageType::BindingResponse => write!(f, "{}", "BindingResponse"),
            MessageType::BindingErrorResponse => write!(f, "{}", "BindingErrorResponse"),
            MessageType::SharedSecretRequest => write!(f, "{}", "SharedSecretRequest"),
            MessageType::SharedSecretResponse => write!(f, "{}", "SharedSecretResponse"),
            MessageType::SharedSecretErrorResponse => write!(f, "{}", "SharedSecretErrorResponse"),
            _ => write!(f, "MessageType({})",self.0),
        }
    }
}
impl std::convert::From<MessageType> for std::option::Option<&str> {
    fn from(e: MessageType) -> Self {
        match e {
            MessageType::BindingRequest => Some("BindingRequest"),
            MessageType::BindingResponse => Some("BindingResponse"),
            MessageType::BindingErrorResponse => Some("BindingErrorResponse"),
            MessageType::SharedSecretRequest => Some("SharedSecretRequest"),
            MessageType::SharedSecretResponse => Some("SharedSecretResponse"),
            MessageType::SharedSecretErrorResponse => Some("SharedSecretErrorResponse"),
            _ =>  None,
        }
    }
}
impl MessageType {
    pub fn is_known(&self) -> bool {
        match *self {
            MessageType::BindingRequest => true,
            MessageType::BindingResponse => true,
            MessageType::BindingErrorResponse => true,
            MessageType::SharedSecretRequest => true,
            MessageType::SharedSecretResponse => true,
            MessageType::SharedSecretErrorResponse => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for MessageType {
    fn from(e: u16) -> Self {
        Self(e)
    }
}
impl std::convert::From<MessageType> for u16 {
    fn from(e: MessageType) -> Self {
        e.0
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct StunAddrFamily(u8);
impl StunAddrFamily  {
    pub const IPv4:Self = Self(1);
    pub const IPv6:Self = Self(2);
}
impl std::fmt::Display for StunAddrFamily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            StunAddrFamily::IPv4 => write!(f, "{}", "IPv4"),
            StunAddrFamily::IPv6 => write!(f, "{}", "IPv6"),
            _ => write!(f, "StunAddrFamily({})",self.0),
        }
    }
}
impl std::convert::From<StunAddrFamily> for std::option::Option<&str> {
    fn from(e: StunAddrFamily) -> Self {
        match e {
            StunAddrFamily::IPv4 => Some("IPv4"),
            StunAddrFamily::IPv6 => Some("IPv6"),
            _ =>  None,
        }
    }
}
impl StunAddrFamily {
    pub fn is_known(&self) -> bool {
        match *self {
            StunAddrFamily::IPv4 => true,
            StunAddrFamily::IPv6 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for StunAddrFamily {
    fn from(e: u8) -> Self {
        Self(e)
    }
}
impl std::convert::From<StunAddrFamily> for u8 {
    fn from(e: StunAddrFamily) -> Self {
        e.0
    }
}
pub const MAGIC_COOKIE: u32 = 554869826;
/* Unimplemented op: DECLARE_FUNCTION */
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct AttributeType(u16);
impl AttributeType  {
    pub const reserved:Self = Self(0);
    pub const mapped_address:Self = Self(1);
    pub const response_address:Self = Self(2);
    pub const change_request:Self = Self(3);
    pub const source_address:Self = Self(4);
    pub const changed_address:Self = Self(5);
    pub const user_name:Self = Self(6);
    pub const password:Self = Self(7);
    pub const message_integrity:Self = Self(8);
    pub const error_code:Self = Self(9);
    pub const unknown_attribute:Self = Self(10);
    pub const reflected_from:Self = Self(11);
    pub const realm:Self = Self(20);
    pub const nonce:Self = Self(21);
    pub const xor_mapped_address:Self = Self(32);
}
impl std::fmt::Display for AttributeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AttributeType::reserved => write!(f, "{}", "reserved"),
            AttributeType::mapped_address => write!(f, "{}", "mapped_address"),
            AttributeType::response_address => write!(f, "{}", "response_address"),
            AttributeType::change_request => write!(f, "{}", "change_request"),
            AttributeType::source_address => write!(f, "{}", "source_address"),
            AttributeType::changed_address => write!(f, "{}", "changed_address"),
            AttributeType::user_name => write!(f, "{}", "user_name"),
            AttributeType::password => write!(f, "{}", "password"),
            AttributeType::message_integrity => write!(f, "{}", "message_integrity"),
            AttributeType::error_code => write!(f, "{}", "error_code"),
            AttributeType::unknown_attribute => write!(f, "{}", "unknown_attribute"),
            AttributeType::reflected_from => write!(f, "{}", "reflected_from"),
            AttributeType::realm => write!(f, "{}", "realm"),
            AttributeType::nonce => write!(f, "{}", "nonce"),
            AttributeType::xor_mapped_address => write!(f, "{}", "xor_mapped_address"),
            _ => write!(f, "AttributeType({})",self.0),
        }
    }
}
impl std::convert::From<AttributeType> for std::option::Option<&str> {
    fn from(e: AttributeType) -> Self {
        match e {
            AttributeType::reserved => Some("reserved"),
            AttributeType::mapped_address => Some("mapped_address"),
            AttributeType::response_address => Some("response_address"),
            AttributeType::change_request => Some("change_request"),
            AttributeType::source_address => Some("source_address"),
            AttributeType::changed_address => Some("changed_address"),
            AttributeType::user_name => Some("user_name"),
            AttributeType::password => Some("password"),
            AttributeType::message_integrity => Some("message_integrity"),
            AttributeType::error_code => Some("error_code"),
            AttributeType::unknown_attribute => Some("unknown_attribute"),
            AttributeType::reflected_from => Some("reflected_from"),
            AttributeType::realm => Some("realm"),
            AttributeType::nonce => Some("nonce"),
            AttributeType::xor_mapped_address => Some("xor_mapped_address"),
            _ =>  None,
        }
    }
}
impl AttributeType {
    pub fn is_known(&self) -> bool {
        match *self {
            AttributeType::reserved => true,
            AttributeType::mapped_address => true,
            AttributeType::response_address => true,
            AttributeType::change_request => true,
            AttributeType::source_address => true,
            AttributeType::changed_address => true,
            AttributeType::user_name => true,
            AttributeType::password => true,
            AttributeType::message_integrity => true,
            AttributeType::error_code => true,
            AttributeType::unknown_attribute => true,
            AttributeType::reflected_from => true,
            AttributeType::realm => true,
            AttributeType::nonce => true,
            AttributeType::xor_mapped_address => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for AttributeType {
    fn from(e: u16) -> Self {
        Self(e)
    }
}
impl std::convert::From<AttributeType> for u16 {
    fn from(e: AttributeType) -> Self {
        e.0
    }
}
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl ChangeRequest {
    pub fn reserved1(&self) -> u32 {
        ((self.field_148>>3) & 536870911) as u32}
    pub fn set_reserved1(&mut self, value: u32) -> bool {
        if value > 536870911 {
        return false;
        }
        self.field_148 = self.field_148& !(536870911<< 3) | ((value as u32) << 3);
        true
    }
}
impl ChangeRequest {
    pub fn change_ip(&self) -> bool {
        ((self.field_148>>2) & 1) as u8 != 0}
    pub fn set_change_ip(&mut self, value: bool) -> bool {
        self.field_148 = self.field_148& !(1<< 2) | ((if value {1} else {0} as u32) << 2);
        true
    }
}
impl ChangeRequest {
    pub fn change_port(&self) -> bool {
        ((self.field_148>>1) & 1) as u8 != 0}
    pub fn set_change_port(&mut self, value: bool) -> bool {
        self.field_148 = self.field_148& !(1<< 1) | ((if value {1} else {0} as u32) << 1);
        true
    }
}
impl ChangeRequest {
    pub fn reserved2(&self) -> bool {
        ((self.field_148>>0) & 1) as u8 != 0}
    pub fn set_reserved2(&mut self, value: bool) -> bool {
        self.field_148 = self.field_148& !(1<< 0) | ((if value {1} else {0} as u32) << 0);
        true
    }
}
impl ErrorCode {
    pub fn reserved(&self) -> u32 {
        ((self.field_155>>10) & 4194303) as u32}
    pub fn set_reserved(&mut self, value: u32) -> bool {
        if value > 4194303 {
        return false;
        }
        self.field_155 = self.field_155& !(4194303<< 10) | ((value as u32) << 10);
        true
    }
}
impl ErrorCode {
    pub fn class(&self) -> u8 {
        ((self.field_155>>7) & 7) as u8}
    pub fn set_class(&mut self, value: u8) -> bool {
        if value > 7 {
        return false;
        }
        self.field_155 = self.field_155& !(7<< 7) | ((value as u32) << 7);
        true
    }
}
impl ErrorCode {
    pub fn number(&self) -> u8 {
        ((self.field_155>>0) & 127) as u8}
    pub fn set_number(&mut self, value: u8) -> bool {
        if value > 127 {
        return false;
        }
        self.field_155 = self.field_155& !(127<< 0) | ((value as u32) << 0);
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant42 {
    pub mapped_address: MappedAddress,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant46 {
    pub change_request: ChangeRequest,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant50 {
    pub error_code: ErrorCode,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant54 {
    pub xor_mapped_address: MappedAddress,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant56 {
    pub data: std::vec::Vec<u8>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
enum Variant41 {
    #[default]
    None,
    Variant42(Variant42),
    Variant46(Variant46),
    Variant50(Variant50),
    Variant54(Variant54),
    Variant56(Variant56),
}
/* Unimplemented op: DEFINE_CONSTANT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct StunHeader {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub msg_type: MessageType,
    pub length: u16,
    pub magic_cookie: u32,
    pub transaction_id: [u8; 12],
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct MappedAddress {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub padding: u8,
    pub family: StunAddrFamily,
    pub port: u16,
    pub address: std::vec::Vec<u8>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ChangeRequest {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_148 :u32,/*reserved1 :29*/
    /*change_ip :1*/
    /*change_port :1*/
    /*reserved2 :1*/
    
    
    
    
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ErrorCode {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_155 :u32,/*reserved :22*/
    /*class :3*/
    /*number :7*/
    
    
    
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Attribute {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub type_: AttributeType,
    pub length: u16,
    pub field40: Variant41,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct StunPacket {
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub header: StunHeader,
    pub attributes: std::vec::Vec<Attribute>,
}
/* Unimplemented op: RETURN_TYPE */
pub fn xor_port(port: u16) -> u16 {
    return (port ^ ((MAGIC_COOKIE >> 16) as u16));
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl StunHeader {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp616 = <[u8; 2]>::default();
        let mut tmp617 = 0;
        while((tmp617 < 2)) {
            (tmp616)[tmp617 as usize] = (((u16::from(self.msg_type) >> ((1 - tmp617) * 8)) & 255) as u8);
            tmp617+= 1;
        }
        w.write_all(&tmp616[0..2 as usize]).map_err(|e| Error::EncodeError("StunHeader::msg_type",e))?;
        let mut tmp629 = <[u8; 2]>::default();
        let mut tmp630 = 0;
        while((tmp630 < 2)) {
            (tmp629)[tmp630 as usize] = (((self.length >> ((1 - tmp630) * 8)) & 255) as u8);
            tmp630+= 1;
        }
        w.write_all(&tmp629[0..2 as usize]).map_err(|e| Error::EncodeError("StunHeader::length",e))?;
        if(!(self.magic_cookie == MAGIC_COOKIE)) { 
        return Err(Error::AssertError("(self.magic_cookie == MAGIC_COOKIE)"));
        }
        let mut tmp642 = <[u8; 4]>::default();
        let mut tmp643 = 0;
        while((tmp643 < 4)) {
            (tmp642)[tmp643 as usize] = (((self.magic_cookie >> ((3 - tmp643) * 8)) & 255) as u8);
            tmp643+= 1;
        }
        w.write_all(&tmp642[0..4 as usize]).map_err(|e| Error::EncodeError("StunHeader::magic_cookie",e))?;
        w.write_all(&self.transaction_id[0..12 as usize]).map_err(|e| Error::EncodeError("StunHeader::transaction_id",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl StunPacket {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.header.encode(w)?;
        let mut tmp_array192 = Vec::with_capacity(self.header.length as usize);
        let mut cursor192 = std::io::Cursor::new(&mut tmp_array192);
        let mut tmp194 = 0;
        while((tmp194 < self.attributes.len())) {
            (self.attributes)[tmp194 as usize].encode(&mut cursor192)?;
            tmp194+= 1;
        }
        if tmp_array192.len() != self.header.length as usize {
            return Err(Error::ArrayLengthMismatch("encode tmp_array192",self.header.length as usize,tmp_array192.len()));
        }
        w.write_all(&tmp_array192).map_err(|e| Error::EncodeError("",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
impl Attribute {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp654 = <[u8; 2]>::default();
        let mut tmp655 = 0;
        while((tmp655 < 2)) {
            (tmp654)[tmp655 as usize] = (((u16::from(self.type_) >> ((1 - tmp655) * 8)) & 255) as u8);
            tmp655+= 1;
        }
        w.write_all(&tmp654[0..2 as usize]).map_err(|e| Error::EncodeError("Attribute::type_",e))?;
        let mut tmp666 = <[u8; 2]>::default();
        let mut tmp667 = 0;
        while((tmp667 < 2)) {
            (tmp666)[tmp667 as usize] = (((self.length >> ((1 - tmp667) * 8)) & 255) as u8);
            tmp667+= 1;
        }
        w.write_all(&tmp666[0..2 as usize]).map_err(|e| Error::EncodeError("Attribute::length",e))?;
        let mut tmp200 = self.type_;
        if (tmp200 == AttributeType::mapped_address) {
            if !matches!(self.field40,Variant41::Variant42(_)) {
                return Err(Error::InvalidUnionVariant("Variant41::Variant42"));
            }
            let mut tmp_array39 = Vec::with_capacity(self.length as usize);
            let mut cursor39 = std::io::Cursor::new(&mut tmp_array39);
            match &self.field40 {  Variant41::Variant42(x) => x, _ => unreachable!() }.mapped_address.encode(&mut cursor39)?;
            if tmp_array39.len() != self.length as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array39",self.length as usize,tmp_array39.len()));
            }
            w.write_all(&tmp_array39).map_err(|e| Error::EncodeError("",e))?;
        } else if((tmp200 == AttributeType::change_request)) {
            if !matches!(self.field40,Variant41::Variant46(_)) {
                return Err(Error::InvalidUnionVariant("Variant41::Variant46"));
            }
            let mut tmp_array39 = Vec::with_capacity(self.length as usize);
            let mut cursor39 = std::io::Cursor::new(&mut tmp_array39);
            match &self.field40 {  Variant41::Variant46(x) => x, _ => unreachable!() }.change_request.encode(&mut cursor39)?;
            if tmp_array39.len() != self.length as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array39",self.length as usize,tmp_array39.len()));
            }
            w.write_all(&tmp_array39).map_err(|e| Error::EncodeError("",e))?;
        } else if((tmp200 == AttributeType::error_code)) {
            if !matches!(self.field40,Variant41::Variant50(_)) {
                return Err(Error::InvalidUnionVariant("Variant41::Variant50"));
            }
            let mut tmp_array39 = Vec::with_capacity(self.length as usize);
            let mut cursor39 = std::io::Cursor::new(&mut tmp_array39);
            match &self.field40 {  Variant41::Variant50(x) => x, _ => unreachable!() }.error_code.encode(&mut cursor39)?;
            if tmp_array39.len() != self.length as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array39",self.length as usize,tmp_array39.len()));
            }
            w.write_all(&tmp_array39).map_err(|e| Error::EncodeError("",e))?;
        } else if((tmp200 == AttributeType::xor_mapped_address)) {
            if !matches!(self.field40,Variant41::Variant54(_)) {
                return Err(Error::InvalidUnionVariant("Variant41::Variant54"));
            }
            let mut tmp_array39 = Vec::with_capacity(self.length as usize);
            let mut cursor39 = std::io::Cursor::new(&mut tmp_array39);
            match &self.field40 {  Variant41::Variant54(x) => x, _ => unreachable!() }.xor_mapped_address.encode(&mut cursor39)?;
            if tmp_array39.len() != self.length as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array39",self.length as usize,tmp_array39.len()));
            }
            w.write_all(&tmp_array39).map_err(|e| Error::EncodeError("",e))?;
        } else {
            if !matches!(self.field40,Variant41::Variant56(_)) {
                return Err(Error::InvalidUnionVariant("Variant41::Variant56"));
            }
            let mut tmp218 = self.length;
            if match &self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data.len() != tmp218 as usize {
            return Err(Error::ArrayLengthMismatch("encode Attribute::Variant41::Variant56::data", tmp218 as usize, match &self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data.len()));
            }
            w.write_all(&match &self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data[0..match &self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::EncodeError("Attribute::Variant41::Variant56::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl MappedAddress {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp679 = <[u8; 1]>::default();
        (tmp679)[0 as usize] = self.padding;
        w.write_all(&tmp679[0..1 as usize]).map_err(|e| Error::EncodeError("MappedAddress::padding",e))?;
        let mut tmp684 = <[u8; 1]>::default();
        (tmp684)[0 as usize] = u8::from(self.family);
        w.write_all(&tmp684[0..1 as usize]).map_err(|e| Error::EncodeError("MappedAddress::family",e))?;
        if(!((self.family == StunAddrFamily::IPv4) || (self.family == StunAddrFamily::IPv6))) { 
        return Err(Error::AssertError("((self.family == StunAddrFamily::IPv4) || (self.family == StunAddrFamily::IPv6))"));
        }
        let mut tmp689 = <[u8; 2]>::default();
        let mut tmp690 = 0;
        while((tmp690 < 2)) {
            (tmp689)[tmp690 as usize] = (((self.port >> ((1 - tmp690) * 8)) & 255) as u8);
            tmp690+= 1;
        }
        w.write_all(&tmp689[0..2 as usize]).map_err(|e| Error::EncodeError("MappedAddress::port",e))?;
        let mut tmp230 = <u8>::default();
        if (self.family == StunAddrFamily::IPv4) {
            tmp230 = (4 as u8);
        } else {
            tmp230 = (16 as u8);
        }
        let mut tmp241 = tmp230;
        if self.address.len() != tmp241 as usize {
        return Err(Error::ArrayLengthMismatch("encode MappedAddress::address", tmp241 as usize, self.address.len()));
        }
        w.write_all(&self.address[0..self.address.len() as usize]).map_err(|e| Error::EncodeError("MappedAddress::address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl ChangeRequest {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp473 = <u32>::default();
        let mut tmp475 = 0;
        tmp475 = (tmp475 + 29);
        tmp473 = (tmp473 | (((self.reserved1() as u32) & 536870911) << (32 - tmp475)));
        tmp475 = (tmp475 + 1);
        tmp473 = (tmp473 | ((if self.change_ip() {1} else {0} & 1) << (32 - tmp475)));
        tmp475 = (tmp475 + 1);
        tmp473 = (tmp473 | ((if self.change_port() {1} else {0} & 1) << (32 - tmp475)));
        tmp475 = (tmp475 + 1);
        tmp473 = (tmp473 | ((if self.reserved2() {1} else {0} & 1) << (32 - tmp475)));
        let mut tmp783 = <[u8; 4]>::default();
        let mut tmp784 = 0;
        while((tmp784 < 4)) {
            (tmp783)[tmp784 as usize] = (((tmp473 >> ((3 - tmp784) * 8)) & 255) as u8);
            tmp784+= 1;
        }
        w.write_all(&tmp783[0..4 as usize]).map_err(|e| Error::EncodeError("ChangeRequest::bit_field_reserved1_change_ip_change_port_reserved2",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl ErrorCode {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp516 = <u32>::default();
        let mut tmp517 = 0;
        tmp517 = (tmp517 + 22);
        tmp516 = (tmp516 | (((self.reserved() as u32) & 4194303) << (32 - tmp517)));
        tmp517 = (tmp517 + 3);
        tmp516 = (tmp516 | (((self.class() as u32) & 7) << (32 - tmp517)));
        tmp517 = (tmp517 + 7);
        tmp516 = (tmp516 | (((self.number() as u32) & 127) << (32 - tmp517)));
        let mut tmp795 = <[u8; 4]>::default();
        let mut tmp796 = 0;
        while((tmp796 < 4)) {
            (tmp795)[tmp796 as usize] = (((tmp516 >> ((3 - tmp796) * 8)) & 255) as u8);
            tmp796+= 1;
        }
        w.write_all(&tmp795[0..4 as usize]).map_err(|e| Error::EncodeError("ErrorCode::bit_field_reserved_class_number",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl StunHeader {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp248 = <u16>::default();
        let mut tmp701 = <[u8; 2]>::default();
        r.read_exact(&mut tmp701[0..2 as usize]).map_err(|e| Error::DecodeError("StunHeader::msg_type",e))?;
        let mut tmp702 = 0;
        while((tmp702 < 2)) {
            tmp248 = (tmp248 | (((tmp701)[tmp702 as usize] as u16) << ((1 - tmp702) * 8)));
            tmp702+= 1;
        }
        self.msg_type = MessageType::from(tmp248);
        let mut tmp713 = <[u8; 2]>::default();
        r.read_exact(&mut tmp713[0..2 as usize]).map_err(|e| Error::DecodeError("StunHeader::length",e))?;
        let mut tmp714 = 0;
        while((tmp714 < 2)) {
            self.length = (self.length | (((tmp713)[tmp714 as usize] as u16) << ((1 - tmp714) * 8)));
            tmp714+= 1;
        }
        let mut tmp725 = <[u8; 4]>::default();
        r.read_exact(&mut tmp725[0..4 as usize]).map_err(|e| Error::DecodeError("StunHeader::magic_cookie",e))?;
        let mut tmp726 = 0;
        while((tmp726 < 4)) {
            self.magic_cookie = (self.magic_cookie | (((tmp725)[tmp726 as usize] as u32) << ((3 - tmp726) * 8)));
            tmp726+= 1;
        }
        if(!(self.magic_cookie == MAGIC_COOKIE)) { 
        return Err(Error::AssertError("(self.magic_cookie == MAGIC_COOKIE)"));
        }
        r.read_exact(&mut self.transaction_id[0..12 as usize]).map_err(|e| Error::DecodeError("StunHeader::transaction_id",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl StunPacket {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
    use std::io::Read;
    use std::io::Seek;
    use std::io::BufRead;
        self.header.decode(r)?;
        let mut tmp_array253 :Vec<u8> = vec![0; self.header.length as usize];
        r.read_exact(&mut tmp_array253).map_err(|e| Error::DecodeError("StunPacket::attributes",e))?;
        let mut cursor253 = std::io::Cursor::new(&tmp_array253);
        while(cursor253.fill_buf().map(|b| !b.is_empty()).map_err(|e| Error::DecodeError("StunPacket::attributes",e))?) {
            let mut tmp257 = <Attribute>::default();
            tmp257.decode(&mut cursor253)?;
            self.attributes.push(tmp257);
        }
        if cursor253.position() != self.header.length as u64 {
            return Err(Error::ArrayLengthMismatch("encode ",self.header.length as usize,cursor253.position() as usize));
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
impl Attribute {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
    use std::io::Read;
    use std::io::Seek;
    use std::io::BufRead;
        let mut tmp260 = <u16>::default();
        let mut tmp737 = <[u8; 2]>::default();
        r.read_exact(&mut tmp737[0..2 as usize]).map_err(|e| Error::DecodeError("Attribute::type_",e))?;
        let mut tmp738 = 0;
        while((tmp738 < 2)) {
            tmp260 = (tmp260 | (((tmp737)[tmp738 as usize] as u16) << ((1 - tmp738) * 8)));
            tmp738+= 1;
        }
        self.type_ = AttributeType::from(tmp260);
        let mut tmp749 = <[u8; 2]>::default();
        r.read_exact(&mut tmp749[0..2 as usize]).map_err(|e| Error::DecodeError("Attribute::length",e))?;
        let mut tmp750 = 0;
        while((tmp750 < 2)) {
            self.length = (self.length | (((tmp749)[tmp750 as usize] as u16) << ((1 - tmp750) * 8)));
            tmp750+= 1;
        }
        let mut tmp263 = self.type_;
        if (tmp263 == AttributeType::mapped_address) {
            if !matches!(self.field40,Variant41::Variant42(_)) {
                self.field40 = Variant41::Variant42(Variant42::default());
            }
            let mut tmp_array39 :Vec<u8> = vec![0; self.length as usize];
            r.read_exact(&mut tmp_array39).map_err(|e| Error::DecodeError("Attribute::Variant41::Variant42::mapped_address",e))?;
            let mut cursor39 = std::io::Cursor::new(&tmp_array39);
            match &mut self.field40 {  Variant41::Variant42(x) => x, _ => unreachable!() }.mapped_address.decode(&mut cursor39)?;
            if cursor39.position() != self.length as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",self.length as usize,cursor39.position() as usize));
            }
        } else if((tmp263 == AttributeType::change_request)) {
            if !matches!(self.field40,Variant41::Variant46(_)) {
                self.field40 = Variant41::Variant46(Variant46::default());
            }
            let mut tmp_array39 :Vec<u8> = vec![0; self.length as usize];
            r.read_exact(&mut tmp_array39).map_err(|e| Error::DecodeError("Attribute::Variant41::Variant46::change_request",e))?;
            let mut cursor39 = std::io::Cursor::new(&tmp_array39);
            match &mut self.field40 {  Variant41::Variant46(x) => x, _ => unreachable!() }.change_request.decode(&mut cursor39)?;
            if cursor39.position() != self.length as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",self.length as usize,cursor39.position() as usize));
            }
        } else if((tmp263 == AttributeType::error_code)) {
            if !matches!(self.field40,Variant41::Variant50(_)) {
                self.field40 = Variant41::Variant50(Variant50::default());
            }
            let mut tmp_array39 :Vec<u8> = vec![0; self.length as usize];
            r.read_exact(&mut tmp_array39).map_err(|e| Error::DecodeError("Attribute::Variant41::Variant50::error_code",e))?;
            let mut cursor39 = std::io::Cursor::new(&tmp_array39);
            match &mut self.field40 {  Variant41::Variant50(x) => x, _ => unreachable!() }.error_code.decode(&mut cursor39)?;
            if cursor39.position() != self.length as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",self.length as usize,cursor39.position() as usize));
            }
        } else if((tmp263 == AttributeType::xor_mapped_address)) {
            if !matches!(self.field40,Variant41::Variant54(_)) {
                self.field40 = Variant41::Variant54(Variant54::default());
            }
            let mut tmp_array39 :Vec<u8> = vec![0; self.length as usize];
            r.read_exact(&mut tmp_array39).map_err(|e| Error::DecodeError("Attribute::Variant41::Variant54::xor_mapped_address",e))?;
            let mut cursor39 = std::io::Cursor::new(&tmp_array39);
            match &mut self.field40 {  Variant41::Variant54(x) => x, _ => unreachable!() }.xor_mapped_address.decode(&mut cursor39)?;
            if cursor39.position() != self.length as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",self.length as usize,cursor39.position() as usize));
            }
        } else {
            if !matches!(self.field40,Variant41::Variant56(_)) {
                self.field40 = Variant41::Variant56(Variant56::default());
            }
            let mut tmp280 = self.length;
            match &mut self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data.resize(tmp280 as usize,0);
            r.read_exact(&mut match &mut self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data).map_err(|e| Error::DecodeError("Attribute::Variant41::Variant56::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl MappedAddress {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp761 = <[u8; 1]>::default();
        r.read_exact(&mut tmp761[0..1 as usize]).map_err(|e| Error::DecodeError("MappedAddress::padding",e))?;
        self.padding = (tmp761)[0 as usize];
        let mut tmp283 = <u8>::default();
        let mut tmp766 = <[u8; 1]>::default();
        r.read_exact(&mut tmp766[0..1 as usize]).map_err(|e| Error::DecodeError("MappedAddress::family",e))?;
        tmp283 = (tmp766)[0 as usize];
        self.family = StunAddrFamily::from(tmp283);
        if(!((self.family == StunAddrFamily::IPv4) || (self.family == StunAddrFamily::IPv6))) { 
        return Err(Error::AssertError("((self.family == StunAddrFamily::IPv4) || (self.family == StunAddrFamily::IPv6))"));
        }
        let mut tmp771 = <[u8; 2]>::default();
        r.read_exact(&mut tmp771[0..2 as usize]).map_err(|e| Error::DecodeError("MappedAddress::port",e))?;
        let mut tmp772 = 0;
        while((tmp772 < 2)) {
            self.port = (self.port | (((tmp771)[tmp772 as usize] as u16) << ((1 - tmp772) * 8)));
            tmp772+= 1;
        }
        let mut tmp294 = <u8>::default();
        if (self.family == StunAddrFamily::IPv4) {
            tmp294 = (4 as u8);
        } else {
            tmp294 = (16 as u8);
        }
        let mut tmp304 = tmp294;
        self.address.resize(tmp304 as usize,0);
        r.read_exact(&mut self.address).map_err(|e| Error::DecodeError("MappedAddress::address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl ChangeRequest {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp549 = <u32>::default();
        let mut tmp550 = 0;
        let mut tmp807 = <[u8; 4]>::default();
        r.read_exact(&mut tmp807[0..4 as usize]).map_err(|e| Error::DecodeError("ChangeRequest::bit_field_reserved1_change_ip_change_port_reserved2",e))?;
        let mut tmp808 = 0;
        while((tmp808 < 4)) {
            tmp549 = (tmp549 | (((tmp807)[tmp808 as usize] as u32) << ((3 - tmp808) * 8)));
            tmp808+= 1;
        }
        tmp550 = (tmp550 + 29);
        self.set_reserved1((((tmp549 >> (32 - tmp550)) & 536870911) as u32));
        tmp550 = (tmp550 + 1);
        self.set_change_ip(((tmp549 >> (32 - tmp550)) & 1) != 0);
        tmp550 = (tmp550 + 1);
        self.set_change_port(((tmp549 >> (32 - tmp550)) & 1) != 0);
        tmp550 = (tmp550 + 1);
        self.set_reserved2(((tmp549 >> (32 - tmp550)) & 1) != 0);
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl ErrorCode {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp586 = <u32>::default();
        let mut tmp587 = 0;
        let mut tmp819 = <[u8; 4]>::default();
        r.read_exact(&mut tmp819[0..4 as usize]).map_err(|e| Error::DecodeError("ErrorCode::bit_field_reserved_class_number",e))?;
        let mut tmp820 = 0;
        while((tmp820 < 4)) {
            tmp586 = (tmp586 | (((tmp819)[tmp820 as usize] as u32) << ((3 - tmp820) * 8)));
            tmp820+= 1;
        }
        tmp587 = (tmp587 + 22);
        self.set_reserved((((tmp586 >> (32 - tmp587)) & 4194303) as u32));
        tmp587 = (tmp587 + 3);
        self.set_class((((tmp586 >> (32 - tmp587)) & 7) as u8));
        tmp587 = (tmp587 + 7);
        self.set_number((((tmp586 >> (32 - tmp587)) & 127) as u8));
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn change_request(&self) -> std::option::Option<&ChangeRequest> {
        let mut tmp61 = self.type_;
        if (tmp61 == AttributeType::mapped_address) {
            return None;
        }
        if (tmp61 == AttributeType::change_request) {
            if !matches!(self.field40,Variant41::Variant46(_)) {
                return None;
            }
            return Some(&match &self.field40 {  Variant41::Variant46(x) => x, _ => unreachable!() }.change_request);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn set_change_request(&mut self, param323: ChangeRequest) -> std::result::Result<(), Error> {
        let mut tmp61 = self.type_;
        if (tmp61 == AttributeType::mapped_address) {
            return Err(Error::PropertySetterError("Attribute::change_request"));
        }
        if (tmp61 == AttributeType::change_request) {
            if !matches!(self.field40,Variant41::Variant46(_)) {
                self.field40 = Variant41::Variant46(Variant46::default());
            }
            match &mut self.field40 {  Variant41::Variant46(x) => x, _ => unreachable!() }.change_request = param323;
            return Ok(());
        }
        return Err(Error::PropertySetterError("Attribute::change_request"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn data(&self) -> std::option::Option<&std::vec::Vec<u8>> {
        let mut tmp74 = self.type_;
        if ((tmp74 == AttributeType::mapped_address) || ((tmp74 == AttributeType::change_request) || ((tmp74 == AttributeType::error_code) || (tmp74 == AttributeType::xor_mapped_address)))) {
            return None;
        }
        if true {
            if !matches!(self.field40,Variant41::Variant56(_)) {
                return None;
            }
            return Some(&match &self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn set_data(&mut self, param334: std::vec::Vec<u8>) -> std::result::Result<(), Error> {
        let mut tmp74 = self.type_;
        if ((tmp74 == AttributeType::mapped_address) || ((tmp74 == AttributeType::change_request) || ((tmp74 == AttributeType::error_code) || (tmp74 == AttributeType::xor_mapped_address)))) {
            return Err(Error::PropertySetterError("Attribute::data"));
        }
        if true {
            if !matches!(self.field40,Variant41::Variant56(_)) {
                self.field40 = Variant41::Variant56(Variant56::default());
            }
            if(!(param334.len() <= 65535)) { 
            return Err(Error::AssertError("(param334.len() <= 65535)"));
            }
            self.length = (param334.len() as u16);
            match &mut self.field40 {  Variant41::Variant56(x) => x, _ => unreachable!() }.data = param334;
            return Ok(());
        }
        return Err(Error::PropertySetterError("Attribute::data"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn error_code(&self) -> std::option::Option<&ErrorCode> {
        let mut tmp97 = self.type_;
        if ((tmp97 == AttributeType::mapped_address) || (tmp97 == AttributeType::change_request)) {
            return None;
        }
        if (tmp97 == AttributeType::error_code) {
            if !matches!(self.field40,Variant41::Variant50(_)) {
                return None;
            }
            return Some(&match &self.field40 {  Variant41::Variant50(x) => x, _ => unreachable!() }.error_code);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn set_error_code(&mut self, param351: ErrorCode) -> std::result::Result<(), Error> {
        let mut tmp97 = self.type_;
        if ((tmp97 == AttributeType::mapped_address) || (tmp97 == AttributeType::change_request)) {
            return Err(Error::PropertySetterError("Attribute::error_code"));
        }
        if (tmp97 == AttributeType::error_code) {
            if !matches!(self.field40,Variant41::Variant50(_)) {
                self.field40 = Variant41::Variant50(Variant50::default());
            }
            match &mut self.field40 {  Variant41::Variant50(x) => x, _ => unreachable!() }.error_code = param351;
            return Ok(());
        }
        return Err(Error::PropertySetterError("Attribute::error_code"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn mapped_address(&self) -> std::option::Option<&MappedAddress> {
        let mut tmp112 = self.type_;
        if (tmp112 == AttributeType::mapped_address) {
            if !matches!(self.field40,Variant41::Variant42(_)) {
                return None;
            }
            return Some(&match &self.field40 {  Variant41::Variant42(x) => x, _ => unreachable!() }.mapped_address);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn set_mapped_address(&mut self, param358: MappedAddress) -> std::result::Result<(), Error> {
        let mut tmp112 = self.type_;
        if (tmp112 == AttributeType::mapped_address) {
            if !matches!(self.field40,Variant41::Variant42(_)) {
                self.field40 = Variant41::Variant42(Variant42::default());
            }
            match &mut self.field40 {  Variant41::Variant42(x) => x, _ => unreachable!() }.mapped_address = param358;
            return Ok(());
        }
        return Err(Error::PropertySetterError("Attribute::mapped_address"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn xor_mapped_address(&self) -> std::option::Option<&MappedAddress> {
        let mut tmp119 = self.type_;
        if ((tmp119 == AttributeType::mapped_address) || ((tmp119 == AttributeType::change_request) || (tmp119 == AttributeType::error_code))) {
            return None;
        }
        if (tmp119 == AttributeType::xor_mapped_address) {
            if !matches!(self.field40,Variant41::Variant54(_)) {
                return None;
            }
            return Some(&match &self.field40 {  Variant41::Variant54(x) => x, _ => unreachable!() }.xor_mapped_address);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl Attribute {
    pub fn set_xor_mapped_address(&mut self, param366: MappedAddress) -> std::result::Result<(), Error> {
        let mut tmp119 = self.type_;
        if ((tmp119 == AttributeType::mapped_address) || ((tmp119 == AttributeType::change_request) || (tmp119 == AttributeType::error_code))) {
            return Err(Error::PropertySetterError("Attribute::xor_mapped_address"));
        }
        if (tmp119 == AttributeType::xor_mapped_address) {
            if !matches!(self.field40,Variant41::Variant54(_)) {
                self.field40 = Variant41::Variant54(Variant54::default());
            }
            match &mut self.field40 {  Variant41::Variant54(x) => x, _ => unreachable!() }.xor_mapped_address = param366;
            return Ok(());
        }
        return Err(Error::PropertySetterError("Attribute::xor_mapped_address"));
    }
}

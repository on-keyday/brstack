// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    IOError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::IOError(s,e) => write!(f, "IOError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::IOError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum Operation {
    #[default]
    Request = 1,
    Reply = 2,
}
impl std::fmt::Display for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u16 {
            1 => write!(f, "{}", "Request"),
            2 => write!(f, "{}", "Reply"),
            _ => write!(f, "Operation({})",*self as u16),
        }
    }
}
impl Operation {
    pub fn is_known(&self) -> bool {
        match *self as u16 {
            1 => true,
            2 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for Operation {
    fn from(e: u16) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<Operation> for u16 {
    fn from(e: Operation) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FORMAT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ArpPacket<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hardware_type: u16,
    pub protocol_type: u16,
    pub hardware_len: u8,
    pub protocol_len: u8,
    pub operation: Operation,
    pub source_hardware_address: std::borrow::Cow<'a,[u8]>,
    pub source_protocol_address: std::borrow::Cow<'a,[u8]>,
    pub target_hardware_address: std::borrow::Cow<'a,[u8]>,
    pub target_protocol_address: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ArpPacket<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp75 = <[u8; 2]>::default();
        let mut tmp78 = 0;
        while((tmp78 < 2)) {
            (tmp75)[tmp78 as usize] = (((self.hardware_type >> ((1 - tmp78) * 8)) & 255) as u8);
            tmp78+= 1;
        }
        w.write_all(&tmp75[0..2 as usize]).map_err(|e| Error::IOError("self.hardware_type",e))?;
        let mut tmp90 = <[u8; 2]>::default();
        let mut tmp91 = 0;
        while((tmp91 < 2)) {
            (tmp90)[tmp91 as usize] = (((self.protocol_type >> ((1 - tmp91) * 8)) & 255) as u8);
            tmp91+= 1;
        }
        w.write_all(&tmp90[0..2 as usize]).map_err(|e| Error::IOError("self.protocol_type",e))?;
        let mut tmp103 = <[u8; 1]>::default();
        (tmp103)[0 as usize] = self.hardware_len;
        w.write_all(&tmp103[0..1 as usize]).map_err(|e| Error::IOError("self.hardware_len",e))?;
        let mut tmp108 = <[u8; 1]>::default();
        (tmp108)[0 as usize] = self.protocol_len;
        w.write_all(&tmp108[0..1 as usize]).map_err(|e| Error::IOError("self.protocol_len",e))?;
        let mut tmp113 = <[u8; 2]>::default();
        let mut tmp114 = 0;
        while((tmp114 < 2)) {
            (tmp113)[tmp114 as usize] = (((u16::from(self.operation) >> ((1 - tmp114) * 8)) & 255) as u8);
            tmp114+= 1;
        }
        w.write_all(&tmp113[0..2 as usize]).map_err(|e| Error::IOError("self.operation",e))?;
        let mut tmp25 = self.hardware_len;
        if self.source_hardware_address.len() != tmp25 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.source_hardware_address", tmp25 as usize, self.source_hardware_address.len()));
        }
        w.write_all(&self.source_hardware_address[0..self.source_hardware_address.len() as usize]).map_err(|e| Error::IOError("self.source_hardware_address",e))?;
        let mut tmp27 = self.protocol_len;
        if self.source_protocol_address.len() != tmp27 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.source_protocol_address", tmp27 as usize, self.source_protocol_address.len()));
        }
        w.write_all(&self.source_protocol_address[0..self.source_protocol_address.len() as usize]).map_err(|e| Error::IOError("self.source_protocol_address",e))?;
        let mut tmp29 = self.hardware_len;
        if self.target_hardware_address.len() != tmp29 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.target_hardware_address", tmp29 as usize, self.target_hardware_address.len()));
        }
        w.write_all(&self.target_hardware_address[0..self.target_hardware_address.len() as usize]).map_err(|e| Error::IOError("self.target_hardware_address",e))?;
        let mut tmp31 = self.protocol_len;
        if self.target_protocol_address.len() != tmp31 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.target_protocol_address", tmp31 as usize, self.target_protocol_address.len()));
        }
        w.write_all(&self.target_protocol_address[0..self.target_protocol_address.len() as usize]).map_err(|e| Error::IOError("self.target_protocol_address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ArpPacket<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp125 = <[u8; 2]>::default();
        r.read_exact(&mut tmp125[0..2 as usize]).map_err(|e| Error::IOError("self.hardware_type",e))?;
        let mut tmp126 = 0;
        while((tmp126 < 2)) {
            self.hardware_type = (self.hardware_type | (((tmp125)[tmp126 as usize] as u16) << ((1 - tmp126) * 8)));
            tmp126+= 1;
        }
        let mut tmp137 = <[u8; 2]>::default();
        r.read_exact(&mut tmp137[0..2 as usize]).map_err(|e| Error::IOError("self.protocol_type",e))?;
        let mut tmp138 = 0;
        while((tmp138 < 2)) {
            self.protocol_type = (self.protocol_type | (((tmp137)[tmp138 as usize] as u16) << ((1 - tmp138) * 8)));
            tmp138+= 1;
        }
        let mut tmp149 = <[u8; 1]>::default();
        r.read_exact(&mut tmp149[0..1 as usize]).map_err(|e| Error::IOError("self.hardware_len",e))?;
        self.hardware_len = (tmp149)[0 as usize];
        let mut tmp154 = <[u8; 1]>::default();
        r.read_exact(&mut tmp154[0..1 as usize]).map_err(|e| Error::IOError("self.protocol_len",e))?;
        self.protocol_len = (tmp154)[0 as usize];
        let mut tmp34 = <u16>::default();
        let mut tmp159 = <[u8; 2]>::default();
        r.read_exact(&mut tmp159[0..2 as usize]).map_err(|e| Error::IOError("self.operation",e))?;
        let mut tmp160 = 0;
        while((tmp160 < 2)) {
            tmp34 = (tmp34 | (((tmp159)[tmp160 as usize] as u16) << ((1 - tmp160) * 8)));
            tmp160+= 1;
        }
        self.operation = Operation::from(tmp34);
        let mut tmp37 = self.hardware_len;
        self.source_hardware_address.to_mut().resize(tmp37 as usize,0);
        r.read_exact(self.source_hardware_address.to_mut()).map_err(|e| Error::IOError("self.source_hardware_address",e))?;
        let mut tmp38 = self.protocol_len;
        self.source_protocol_address.to_mut().resize(tmp38 as usize,0);
        r.read_exact(self.source_protocol_address.to_mut()).map_err(|e| Error::IOError("self.source_protocol_address",e))?;
        let mut tmp39 = self.hardware_len;
        self.target_hardware_address.to_mut().resize(tmp39 as usize,0);
        r.read_exact(self.target_hardware_address.to_mut()).map_err(|e| Error::IOError("self.target_hardware_address",e))?;
        let mut tmp40 = self.protocol_len;
        self.target_protocol_address.to_mut().resize(tmp40 as usize,0);
        r.read_exact(self.target_protocol_address.to_mut()).map_err(|e| Error::IOError("self.target_protocol_address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_source_hardware_address(&mut self, param45: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param45.len() <= 255)) { 
        return Err(Error::AssertError("(param45.len() <= 255)"));
        }
        self.hardware_len = (param45.len() as u8);
        self.source_hardware_address = param45;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_source_protocol_address(&mut self, param54: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param54.len() <= 255)) { 
        return Err(Error::AssertError("(param54.len() <= 255)"));
        }
        self.protocol_len = (param54.len() as u8);
        self.source_protocol_address = param54;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_target_hardware_address(&mut self, param60: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param60.len() <= 255)) { 
        return Err(Error::AssertError("(param60.len() <= 255)"));
        }
        self.hardware_len = (param60.len() as u8);
        self.target_hardware_address = param60;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_target_protocol_address(&mut self, param66: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param66.len() <= 255)) { 
        return Err(Error::AssertError("(param66.len() <= 255)"));
        }
        self.protocol_len = (param66.len() as u8);
        self.target_protocol_address = param66;
        return Ok(());
    }
}

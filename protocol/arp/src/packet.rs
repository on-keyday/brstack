// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    IOError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::IOError(s,e) => write!(f, "IOError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::IOError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum Operation {
    #[default]
    Request = 1,
    Reply = 2,
}
impl std::fmt::Display for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u16 {
            1 => write!(f, "{}", "Request"),
            2 => write!(f, "{}", "Reply"),
            _ => write!(f, "Operation({})",*self as u16),
        }
    }
}
impl Operation {
    pub fn is_known(&self) -> bool {
        match *self as u16 {
            1 => true,
            2 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for Operation {
    fn from(e: u16) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<Operation> for u16 {
    fn from(e: Operation) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: CAST */
pub const HARDWARE_TYPE_ETHERNET: u16 = 1;
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: CAST */
/* Unimplemented op: DEFINE_CONSTANT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ArpPacket<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hardware_type: u16,
    pub protocol_type: u16,
    pub hardware_len: u8,
    pub protocol_len: u8,
    pub operation: Operation,
    pub source_hardware_address: std::borrow::Cow<'a,[u8]>,
    pub source_protocol_address: std::borrow::Cow<'a,[u8]>,
    pub target_hardware_address: std::borrow::Cow<'a,[u8]>,
    pub target_protocol_address: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ArpPacket<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp80 = <[u8; 2]>::default();
        let mut tmp83 = 0;
        while((tmp83 < 2)) {
            (tmp80)[tmp83 as usize] = (((self.hardware_type >> ((1 - tmp83) * 8)) & 255) as u8);
            tmp83+= 1;
        }
        w.write_all(&tmp80[0..2 as usize]).map_err(|e| Error::IOError("self.hardware_type",e))?;
        let mut tmp95 = <[u8; 2]>::default();
        let mut tmp96 = 0;
        while((tmp96 < 2)) {
            (tmp95)[tmp96 as usize] = (((self.protocol_type >> ((1 - tmp96) * 8)) & 255) as u8);
            tmp96+= 1;
        }
        w.write_all(&tmp95[0..2 as usize]).map_err(|e| Error::IOError("self.protocol_type",e))?;
        let mut tmp108 = <[u8; 1]>::default();
        (tmp108)[0 as usize] = self.hardware_len;
        w.write_all(&tmp108[0..1 as usize]).map_err(|e| Error::IOError("self.hardware_len",e))?;
        let mut tmp113 = <[u8; 1]>::default();
        (tmp113)[0 as usize] = self.protocol_len;
        w.write_all(&tmp113[0..1 as usize]).map_err(|e| Error::IOError("self.protocol_len",e))?;
        let mut tmp118 = <[u8; 2]>::default();
        let mut tmp119 = 0;
        while((tmp119 < 2)) {
            (tmp118)[tmp119 as usize] = (((u16::from(self.operation) >> ((1 - tmp119) * 8)) & 255) as u8);
            tmp119+= 1;
        }
        w.write_all(&tmp118[0..2 as usize]).map_err(|e| Error::IOError("self.operation",e))?;
        let mut tmp28 = self.hardware_len;
        if self.source_hardware_address.len() != tmp28 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.source_hardware_address", tmp28 as usize, self.source_hardware_address.len()));
        }
        w.write_all(&self.source_hardware_address[0..self.source_hardware_address.len() as usize]).map_err(|e| Error::IOError("self.source_hardware_address",e))?;
        let mut tmp30 = self.protocol_len;
        if self.source_protocol_address.len() != tmp30 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.source_protocol_address", tmp30 as usize, self.source_protocol_address.len()));
        }
        w.write_all(&self.source_protocol_address[0..self.source_protocol_address.len() as usize]).map_err(|e| Error::IOError("self.source_protocol_address",e))?;
        let mut tmp32 = self.hardware_len;
        if self.target_hardware_address.len() != tmp32 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.target_hardware_address", tmp32 as usize, self.target_hardware_address.len()));
        }
        w.write_all(&self.target_hardware_address[0..self.target_hardware_address.len() as usize]).map_err(|e| Error::IOError("self.target_hardware_address",e))?;
        let mut tmp34 = self.protocol_len;
        if self.target_protocol_address.len() != tmp34 as usize {
        return Err(Error::ArrayLengthMismatch("encode self.target_protocol_address", tmp34 as usize, self.target_protocol_address.len()));
        }
        w.write_all(&self.target_protocol_address[0..self.target_protocol_address.len() as usize]).map_err(|e| Error::IOError("self.target_protocol_address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ArpPacket<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp130 = <[u8; 2]>::default();
        r.read_exact(&mut tmp130[0..2 as usize]).map_err(|e| Error::IOError("self.hardware_type",e))?;
        let mut tmp131 = 0;
        while((tmp131 < 2)) {
            self.hardware_type = (self.hardware_type | (((tmp130)[tmp131 as usize] as u16) << ((1 - tmp131) * 8)));
            tmp131+= 1;
        }
        let mut tmp142 = <[u8; 2]>::default();
        r.read_exact(&mut tmp142[0..2 as usize]).map_err(|e| Error::IOError("self.protocol_type",e))?;
        let mut tmp143 = 0;
        while((tmp143 < 2)) {
            self.protocol_type = (self.protocol_type | (((tmp142)[tmp143 as usize] as u16) << ((1 - tmp143) * 8)));
            tmp143+= 1;
        }
        let mut tmp154 = <[u8; 1]>::default();
        r.read_exact(&mut tmp154[0..1 as usize]).map_err(|e| Error::IOError("self.hardware_len",e))?;
        self.hardware_len = (tmp154)[0 as usize];
        let mut tmp159 = <[u8; 1]>::default();
        r.read_exact(&mut tmp159[0..1 as usize]).map_err(|e| Error::IOError("self.protocol_len",e))?;
        self.protocol_len = (tmp159)[0 as usize];
        let mut tmp38 = <u16>::default();
        let mut tmp164 = <[u8; 2]>::default();
        r.read_exact(&mut tmp164[0..2 as usize]).map_err(|e| Error::IOError("self.operation",e))?;
        let mut tmp165 = 0;
        while((tmp165 < 2)) {
            tmp38 = (tmp38 | (((tmp164)[tmp165 as usize] as u16) << ((1 - tmp165) * 8)));
            tmp165+= 1;
        }
        self.operation = Operation::from(tmp38);
        let mut tmp41 = self.hardware_len;
        self.source_hardware_address.to_mut().resize(tmp41 as usize,0);
        r.read_exact(self.source_hardware_address.to_mut()).map_err(|e| Error::IOError("self.source_hardware_address",e))?;
        let mut tmp42 = self.protocol_len;
        self.source_protocol_address.to_mut().resize(tmp42 as usize,0);
        r.read_exact(self.source_protocol_address.to_mut()).map_err(|e| Error::IOError("self.source_protocol_address",e))?;
        let mut tmp43 = self.hardware_len;
        self.target_hardware_address.to_mut().resize(tmp43 as usize,0);
        r.read_exact(self.target_hardware_address.to_mut()).map_err(|e| Error::IOError("self.target_hardware_address",e))?;
        let mut tmp44 = self.protocol_len;
        self.target_protocol_address.to_mut().resize(tmp44 as usize,0);
        r.read_exact(self.target_protocol_address.to_mut()).map_err(|e| Error::IOError("self.target_protocol_address",e))?;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_source_hardware_address(&mut self, param50: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param50.len() <= 255)) { 
        return Err(Error::AssertError("(param50.len() <= 255)"));
        }
        self.hardware_len = (param50.len() as u8);
        self.source_hardware_address = param50;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_source_protocol_address(&mut self, param59: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param59.len() <= 255)) { 
        return Err(Error::AssertError("(param59.len() <= 255)"));
        }
        self.protocol_len = (param59.len() as u8);
        self.source_protocol_address = param59;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_target_hardware_address(&mut self, param65: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param65.len() <= 255)) { 
        return Err(Error::AssertError("(param65.len() <= 255)"));
        }
        self.hardware_len = (param65.len() as u8);
        self.target_hardware_address = param65;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ArpPacket<'a> {
    pub fn set_target_protocol_address(&mut self, param71: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param71.len() <= 255)) { 
        return Err(Error::AssertError("(param71.len() <= 255)"));
        }
        self.protocol_len = (param71.len() as u8);
        self.target_protocol_address = param71;
        return Ok(());
    }
}

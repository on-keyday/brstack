// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    IOError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::IOError(s,e) => write!(f, "IOError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::IOError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum EtherType {
    #[default]
    IPv4 = 2048,
    ARP = 2054,
    IPv6 = 34525,
}
impl std::fmt::Display for EtherType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u16 {
            2048 => write!(f, "{}", "IPv4"),
            2054 => write!(f, "{}", "ARP"),
            34525 => write!(f, "{}", "IPv6"),
            _ => write!(f, "EtherType({})",*self as u16),
        }
    }
}
impl EtherType {
    pub fn is_known(&self) -> bool {
        match *self as u16 {
            2048 => true,
            2054 => true,
            34525 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for EtherType {
    fn from(e: u16) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<EtherType> for u16 {
    fn from(e: EtherType) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FORMAT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant18<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant21<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
enum Variant17<'a> {
    #[default]
    None,
    Variant18(Variant18<'a>),
    Variant21(Variant21<'a>),
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct EthernetFrame<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub dst_mac: [u8; 6],
    pub src_mac: [u8; 6],
    pub ether_type: EtherType,
    pub field16: Variant17<'a>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>EthernetFrame<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.dst_mac[0..6 as usize]).map_err(|e| Error::IOError("self.dst_mac",e))?;
        w.write_all(&self.src_mac[0..6 as usize]).map_err(|e| Error::IOError("self.src_mac",e))?;
        let mut tmp73 = <[u8; 2]>::default();
        let mut tmp77 = 0;
        while((tmp77 < 2)) {
            (tmp73)[tmp77 as usize] = (((u16::from(self.ether_type) >> ((1 - tmp77) * 8)) & 255) as u8);
            tmp77+= 1;
        }
        w.write_all(&tmp73[0..2 as usize]).map_err(|e| Error::IOError("self.ether_type",e))?;
        let mut len = u16::from(self.ether_type);
        if(!((len <= 1500) || (len >= 1536))) { 
        return Err(Error::AssertError("((len <= 1500) || (len >= 1536))"));
        }
        if (len >= 1536) {
            if !matches!(self.field16,Variant17::Variant18(_)) {
                return Err(Error::InvalidUnionVariant("Variant17::Variant18"));
            }
            w.write_all(&match &self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data[0..match &self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::IOError("match &self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data",e))?;
        } else {
            if !matches!(self.field16,Variant17::Variant21(_)) {
                return Err(Error::InvalidUnionVariant("Variant17::Variant21"));
            }
            let mut tmp46 = len;
            if match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data.len() != tmp46 as usize {
            return Err(Error::ArrayLengthMismatch("encode match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data", tmp46 as usize, match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data.len()));
            }
            w.write_all(&match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data[0..match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::IOError("match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>EthernetFrame<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.dst_mac[0..6 as usize]).map_err(|e| Error::IOError("self.dst_mac",e))?;
        r.read_exact(&mut self.src_mac[0..6 as usize]).map_err(|e| Error::IOError("self.src_mac",e))?;
        let mut tmp49 = <u16>::default();
        let mut tmp92 = <[u8; 2]>::default();
        r.read_exact(&mut tmp92[0..2 as usize]).map_err(|e| Error::IOError("self.ether_type",e))?;
        let mut tmp93 = 0;
        while((tmp93 < 2)) {
            tmp49 = (tmp49 | (((tmp92)[tmp93 as usize] as u16) << ((1 - tmp93) * 8)));
            tmp93+= 1;
        }
        self.ether_type = EtherType::from(tmp49);
        let mut len = u16::from(self.ether_type);
        if(!((len <= 1500) || (len >= 1536))) { 
        return Err(Error::AssertError("((len <= 1500) || (len >= 1536))"));
        }
        if (len >= 1536) {
            if !matches!(self.field16,Variant17::Variant18(_)) {
                self.field16 = Variant17::Variant18(Variant18::default());
            }
            r.read_to_end(match &mut self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::IOError("match &self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data",e))?;
        } else {
            if !matches!(self.field16,Variant17::Variant21(_)) {
                self.field16 = Variant17::Variant21(Variant21::default());
            }
            let mut tmp58 = len;
            match &mut self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data.to_mut().resize(tmp58 as usize,0);
            r.read_exact(match &mut self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::IOError("match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>EthernetFrame<'a> {
    pub fn data(&self) -> std::option::Option<&std::borrow::Cow<'a,[u8]>> {
        let mut len = u16::from(self.ether_type);
        if (len >= 1536) {
            if !matches!(self.field16,Variant17::Variant18(_)) {
                return None;
            }
            return Some(&match &self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data);
        }
        if true {
            if !matches!(self.field16,Variant17::Variant21(_)) {
                return None;
            }
            return Some(&match &self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>EthernetFrame<'a> {
    pub fn set_data(&mut self, param65: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        let mut len = u16::from(self.ether_type);
        if (len >= 1536) {
            if !matches!(self.field16,Variant17::Variant18(_)) {
                self.field16 = Variant17::Variant18(Variant18::default());
            }
            match &mut self.field16 {  Variant17::Variant18(x) => x, _ => unreachable!() }.data = param65;
            return Ok(());
        }
        if true {
            if !matches!(self.field16,Variant17::Variant21(_)) {
                self.field16 = Variant17::Variant21(Variant21::default());
            }
            match &mut self.field16 {  Variant17::Variant21(x) => x, _ => unreachable!() }.data = param65;
            return Ok(());
        }
        return Err(Error::PropertySetterError("data"));
    }
}

// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u16)]
pub enum EtherType {
    #[default]
    IPv4 = 2048,
    ARP = 2054,
    IPv6 = 34525,
    BRSTACK = 45228,
}
impl std::fmt::Display for EtherType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u16 {
            2048 => write!(f, "{}", "IPv4"),
            2054 => write!(f, "{}", "ARP"),
            34525 => write!(f, "{}", "IPv6"),
            45228 => write!(f, "{}", "BRSTACK"),
            _ => write!(f, "EtherType({})",*self as u16),
        }
    }
}
impl EtherType {
    pub fn is_known(&self) -> bool {
        match *self as u16 {
            2048 => true,
            2054 => true,
            34525 => true,
            45228 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u16> for EtherType {
    fn from(e: u16) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<EtherType> for u16 {
    fn from(e: EtherType) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FORMAT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant20<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant23<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
enum Variant19<'a> {
    #[default]
    None,
    Variant20(Variant20<'a>),
    Variant23(Variant23<'a>),
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct EthernetFrame<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub dst_mac: [u8; 6],
    pub src_mac: [u8; 6],
    pub ether_type: EtherType,
    pub field18: Variant19<'a>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>EthernetFrame<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.dst_mac[0..6 as usize]).map_err(|e| Error::EncodeError("EthernetFrame::dst_mac",e))?;
        w.write_all(&self.src_mac[0..6 as usize]).map_err(|e| Error::EncodeError("EthernetFrame::src_mac",e))?;
        let mut tmp75 = <[u8; 2]>::default();
        let mut tmp79 = 0;
        while((tmp79 < 2)) {
            (tmp75)[tmp79 as usize] = (((u16::from(self.ether_type) >> ((1 - tmp79) * 8)) & 255) as u8);
            tmp79+= 1;
        }
        w.write_all(&tmp75[0..2 as usize]).map_err(|e| Error::EncodeError("EthernetFrame::ether_type",e))?;
        let mut len = u16::from(self.ether_type);
        if(!((len <= 1500) || (len >= 1536))) { 
        return Err(Error::AssertError("((len <= 1500) || (len >= 1536))"));
        }
        if (len >= 1536) {
            if !matches!(self.field18,Variant19::Variant20(_)) {
                return Err(Error::InvalidUnionVariant("Variant19::Variant20"));
            }
            w.write_all(&match &self.field18 {  Variant19::Variant20(x) => x, _ => unreachable!() }.data[0..match &self.field18 {  Variant19::Variant20(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::EncodeError("EthernetFrame::Variant19::Variant20::data",e))?;
        } else {
            if !matches!(self.field18,Variant19::Variant23(_)) {
                return Err(Error::InvalidUnionVariant("Variant19::Variant23"));
            }
            let mut tmp48 = len;
            if match &self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data.len() != tmp48 as usize {
            return Err(Error::ArrayLengthMismatch("encode EthernetFrame::Variant19::Variant23::data", tmp48 as usize, match &self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data.len()));
            }
            w.write_all(&match &self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data[0..match &self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::EncodeError("EthernetFrame::Variant19::Variant23::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>EthernetFrame<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.dst_mac[0..6 as usize]).map_err(|e| Error::DecodeError("EthernetFrame::dst_mac",e))?;
        r.read_exact(&mut self.src_mac[0..6 as usize]).map_err(|e| Error::DecodeError("EthernetFrame::src_mac",e))?;
        let mut tmp51 = <u16>::default();
        let mut tmp94 = <[u8; 2]>::default();
        r.read_exact(&mut tmp94[0..2 as usize]).map_err(|e| Error::DecodeError("EthernetFrame::ether_type",e))?;
        let mut tmp95 = 0;
        while((tmp95 < 2)) {
            tmp51 = (tmp51 | (((tmp94)[tmp95 as usize] as u16) << ((1 - tmp95) * 8)));
            tmp95+= 1;
        }
        self.ether_type = EtherType::from(tmp51);
        let mut len = u16::from(self.ether_type);
        if(!((len <= 1500) || (len >= 1536))) { 
        return Err(Error::AssertError("((len <= 1500) || (len >= 1536))"));
        }
        if (len >= 1536) {
            if !matches!(self.field18,Variant19::Variant20(_)) {
                self.field18 = Variant19::Variant20(Variant20::default());
            }
            r.read_to_end(match &mut self.field18 {  Variant19::Variant20(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::DecodeError("EthernetFrame::Variant19::Variant20::data",e))?;
        } else {
            if !matches!(self.field18,Variant19::Variant23(_)) {
                self.field18 = Variant19::Variant23(Variant23::default());
            }
            let mut tmp60 = len;
            match &mut self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data.to_mut().resize(tmp60 as usize,0);
            r.read_exact(match &mut self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::DecodeError("EthernetFrame::Variant19::Variant23::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>EthernetFrame<'a> {
    pub fn data(&self) -> std::option::Option<&std::borrow::Cow<'a,[u8]>> {
        let mut len = u16::from(self.ether_type);
        if (len >= 1536) {
            if !matches!(self.field18,Variant19::Variant20(_)) {
                return None;
            }
            return Some(&match &self.field18 {  Variant19::Variant20(x) => x, _ => unreachable!() }.data);
        }
        if true {
            if !matches!(self.field18,Variant19::Variant23(_)) {
                return None;
            }
            return Some(&match &self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>EthernetFrame<'a> {
    pub fn set_data(&mut self, param67: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        let mut len = u16::from(self.ether_type);
        if (len >= 1536) {
            if !matches!(self.field18,Variant19::Variant20(_)) {
                self.field18 = Variant19::Variant20(Variant20::default());
            }
            match &mut self.field18 {  Variant19::Variant20(x) => x, _ => unreachable!() }.data = param67;
            return Ok(());
        }
        if true {
            if !matches!(self.field18,Variant19::Variant23(_)) {
                self.field18 = Variant19::Variant23(Variant23::default());
            }
            match &mut self.field18 {  Variant19::Variant23(x) => x, _ => unreachable!() }.data = param67;
            return Ok(());
        }
        return Err(Error::PropertySetterError("EthernetFrame::data"));
    }
}

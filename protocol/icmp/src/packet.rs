// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum ICMPv4Type {
    #[default]
    echo_reply = 0,
    reserved_1 = 1,
    reserved_2 = 2,
    dst_unreachable = 3,
    src_quench = 4,
    redirect = 5,
    alt_host_address = 6,
    reserved_3 = 7,
    echo = 8,
    router_advertisement = 9,
    router_solicitation = 10,
    time_exceeded = 11,
    parameter_problem = 12,
    timestamp = 13,
    timestamp_reply = 14,
}
impl std::fmt::Display for ICMPv4Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self as u8 {
            0 => write!(f, "{}", "echo_reply"),
            1 => write!(f, "{}", "reserved_1"),
            2 => write!(f, "{}", "reserved_2"),
            3 => write!(f, "{}", "dst_unreachable"),
            4 => write!(f, "{}", "src_quench"),
            5 => write!(f, "{}", "redirect"),
            6 => write!(f, "{}", "alt_host_address"),
            7 => write!(f, "{}", "reserved_3"),
            8 => write!(f, "{}", "echo"),
            9 => write!(f, "{}", "router_advertisement"),
            10 => write!(f, "{}", "router_solicitation"),
            11 => write!(f, "{}", "time_exceeded"),
            12 => write!(f, "{}", "parameter_problem"),
            13 => write!(f, "{}", "timestamp"),
            14 => write!(f, "{}", "timestamp_reply"),
            _ => write!(f, "ICMPv4Type({})",*self as u8),
        }
    }
}
impl ICMPv4Type {
    pub fn is_known(&self) -> bool {
        match *self as u8 {
            0 => true,
            1 => true,
            2 => true,
            3 => true,
            4 => true,
            5 => true,
            6 => true,
            7 => true,
            8 => true,
            9 => true,
            10 => true,
            11 => true,
            12 => true,
            13 => true,
            14 => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for ICMPv4Type {
    fn from(e: u8) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
impl std::convert::From<ICMPv4Type> for u8 {
    fn from(e: ICMPv4Type) -> Self {
        unsafe { std::mem::transmute(e) }
    }
}
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant8<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub echo: ICMPEcho<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant12<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub echo_reply: ICMPEcho<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant14<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub time_exceeded: ICMPTimeExceeded<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant18<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub destination_unreachable: ICMPDestinationUnreachable<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant22<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub redirect: ICMPRedirect<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant26<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub parameter_problem: ICMPParameterProblem<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant30<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub timestamp: ICMPTimestamp<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant34<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub timestamp_reply: ICMPTimestamp<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant36<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
enum Variant7<'a> {
    #[default]
    None,
    Variant8(Variant8<'a>),
    Variant12(Variant12<'a>),
    Variant14(Variant14<'a>),
    Variant18(Variant18<'a>),
    Variant22(Variant22<'a>),
    Variant26(Variant26<'a>),
    Variant30(Variant30<'a>),
    Variant34(Variant34<'a>),
    Variant36(Variant36<'a>),
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub type_: u8,
    pub code: u8,
    pub checksum: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPTimeExceeded<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub unused: u32,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPEcho<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub id: u16,
    pub seq: u16,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPDestinationUnreachable<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub unused: u16,
    pub next_hop_mtu: u16,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPPacketTooBig<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub unused: u32,
    pub mtu: u32,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPRedirect<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub gateway: [u8; 4],
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPTimestamp<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub id: u16,
    pub seq: u16,
    pub originate: u32,
    pub receive: u32,
    pub transmit: u32,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPParameterProblem<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub pointer: u8,
    pub unused: u32,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ICMPv4Packet<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub header: ICMPHeader<'a>,
    pub field6: Variant7<'a>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>ICMPv4Packet<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.header.encode(w)?;
        let mut tmp329 = ICMPv4Type::from(self.header.type_);
        if (tmp329 == ICMPv4Type::echo) {
            if !matches!(self.field6,Variant7::Variant8(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant8"));
            }
            match &self.field6 {  Variant7::Variant8(x) => x, _ => unreachable!() }.echo.encode(w)?;
        } else if((tmp329 == ICMPv4Type::echo_reply)) {
            if !matches!(self.field6,Variant7::Variant12(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant12"));
            }
            match &self.field6 {  Variant7::Variant12(x) => x, _ => unreachable!() }.echo_reply.encode(w)?;
        } else if((tmp329 == ICMPv4Type::time_exceeded)) {
            if !matches!(self.field6,Variant7::Variant14(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant14"));
            }
            match &self.field6 {  Variant7::Variant14(x) => x, _ => unreachable!() }.time_exceeded.encode(w)?;
        } else if((tmp329 == ICMPv4Type::dst_unreachable)) {
            if !matches!(self.field6,Variant7::Variant18(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant18"));
            }
            match &self.field6 {  Variant7::Variant18(x) => x, _ => unreachable!() }.destination_unreachable.encode(w)?;
        } else if((tmp329 == ICMPv4Type::redirect)) {
            if !matches!(self.field6,Variant7::Variant22(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant22"));
            }
            match &self.field6 {  Variant7::Variant22(x) => x, _ => unreachable!() }.redirect.encode(w)?;
        } else if((tmp329 == ICMPv4Type::parameter_problem)) {
            if !matches!(self.field6,Variant7::Variant26(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant26"));
            }
            match &self.field6 {  Variant7::Variant26(x) => x, _ => unreachable!() }.parameter_problem.encode(w)?;
        } else if((tmp329 == ICMPv4Type::timestamp)) {
            if !matches!(self.field6,Variant7::Variant30(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant30"));
            }
            match &self.field6 {  Variant7::Variant30(x) => x, _ => unreachable!() }.timestamp.encode(w)?;
        } else if((tmp329 == ICMPv4Type::timestamp_reply)) {
            if !matches!(self.field6,Variant7::Variant34(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant34"));
            }
            match &self.field6 {  Variant7::Variant34(x) => x, _ => unreachable!() }.timestamp_reply.encode(w)?;
        } else {
            if !matches!(self.field6,Variant7::Variant36(_)) {
                return Err(Error::InvalidUnionVariant("Variant7::Variant36"));
            }
            w.write_all(&match &self.field6 {  Variant7::Variant36(x) => x, _ => unreachable!() }.data[0..match &self.field6 {  Variant7::Variant36(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPv4Packet::Variant7::Variant36::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp559 = <[u8; 1]>::default();
        (tmp559)[0 as usize] = self.type_;
        w.write_all(&tmp559[0..1 as usize]).map_err(|e| Error::EncodeError("ICMPHeader::type_",e))?;
        let mut tmp564 = <[u8; 1]>::default();
        (tmp564)[0 as usize] = self.code;
        w.write_all(&tmp564[0..1 as usize]).map_err(|e| Error::EncodeError("ICMPHeader::code",e))?;
        let mut tmp570 = <[u8; 2]>::default();
        let mut tmp572 = 0;
        while((tmp572 < 2)) {
            (tmp570)[tmp572 as usize] = (((self.checksum >> ((1 - tmp572) * 8)) & 255) as u8);
            tmp572+= 1;
        }
        w.write_all(&tmp570[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPHeader::checksum",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPTimeExceeded<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp584 = <[u8; 4]>::default();
        let mut tmp585 = 0;
        while((tmp585 < 4)) {
            (tmp584)[tmp585 as usize] = (((self.unused >> ((3 - tmp585) * 8)) & 255) as u8);
            tmp585+= 1;
        }
        w.write_all(&tmp584[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPTimeExceeded::unused",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPTimeExceeded::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPEcho<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp596 = <[u8; 2]>::default();
        let mut tmp597 = 0;
        while((tmp597 < 2)) {
            (tmp596)[tmp597 as usize] = (((self.id >> ((1 - tmp597) * 8)) & 255) as u8);
            tmp597+= 1;
        }
        w.write_all(&tmp596[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPEcho::id",e))?;
        let mut tmp608 = <[u8; 2]>::default();
        let mut tmp609 = 0;
        while((tmp609 < 2)) {
            (tmp608)[tmp609 as usize] = (((self.seq >> ((1 - tmp609) * 8)) & 255) as u8);
            tmp609+= 1;
        }
        w.write_all(&tmp608[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPEcho::seq",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPEcho::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPDestinationUnreachable<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp620 = <[u8; 2]>::default();
        let mut tmp621 = 0;
        while((tmp621 < 2)) {
            (tmp620)[tmp621 as usize] = (((self.unused >> ((1 - tmp621) * 8)) & 255) as u8);
            tmp621+= 1;
        }
        w.write_all(&tmp620[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPDestinationUnreachable::unused",e))?;
        let mut tmp632 = <[u8; 2]>::default();
        let mut tmp633 = 0;
        while((tmp633 < 2)) {
            (tmp632)[tmp633 as usize] = (((self.next_hop_mtu >> ((1 - tmp633) * 8)) & 255) as u8);
            tmp633+= 1;
        }
        w.write_all(&tmp632[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPDestinationUnreachable::next_hop_mtu",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPDestinationUnreachable::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPPacketTooBig<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp644 = <[u8; 4]>::default();
        let mut tmp645 = 0;
        while((tmp645 < 4)) {
            (tmp644)[tmp645 as usize] = (((self.unused >> ((3 - tmp645) * 8)) & 255) as u8);
            tmp645+= 1;
        }
        w.write_all(&tmp644[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPPacketTooBig::unused",e))?;
        let mut tmp656 = <[u8; 4]>::default();
        let mut tmp657 = 0;
        while((tmp657 < 4)) {
            (tmp656)[tmp657 as usize] = (((self.mtu >> ((3 - tmp657) * 8)) & 255) as u8);
            tmp657+= 1;
        }
        w.write_all(&tmp656[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPPacketTooBig::mtu",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPPacketTooBig::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>ICMPRedirect<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.gateway[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPRedirect::gateway",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPRedirect::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPTimestamp<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp668 = <[u8; 2]>::default();
        let mut tmp669 = 0;
        while((tmp669 < 2)) {
            (tmp668)[tmp669 as usize] = (((self.id >> ((1 - tmp669) * 8)) & 255) as u8);
            tmp669+= 1;
        }
        w.write_all(&tmp668[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPTimestamp::id",e))?;
        let mut tmp680 = <[u8; 2]>::default();
        let mut tmp681 = 0;
        while((tmp681 < 2)) {
            (tmp680)[tmp681 as usize] = (((self.seq >> ((1 - tmp681) * 8)) & 255) as u8);
            tmp681+= 1;
        }
        w.write_all(&tmp680[0..2 as usize]).map_err(|e| Error::EncodeError("ICMPTimestamp::seq",e))?;
        let mut tmp692 = <[u8; 4]>::default();
        let mut tmp693 = 0;
        while((tmp693 < 4)) {
            (tmp692)[tmp693 as usize] = (((self.originate >> ((3 - tmp693) * 8)) & 255) as u8);
            tmp693+= 1;
        }
        w.write_all(&tmp692[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPTimestamp::originate",e))?;
        let mut tmp704 = <[u8; 4]>::default();
        let mut tmp705 = 0;
        while((tmp705 < 4)) {
            (tmp704)[tmp705 as usize] = (((self.receive >> ((3 - tmp705) * 8)) & 255) as u8);
            tmp705+= 1;
        }
        w.write_all(&tmp704[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPTimestamp::receive",e))?;
        let mut tmp716 = <[u8; 4]>::default();
        let mut tmp717 = 0;
        while((tmp717 < 4)) {
            (tmp716)[tmp717 as usize] = (((self.transmit >> ((3 - tmp717) * 8)) & 255) as u8);
            tmp717+= 1;
        }
        w.write_all(&tmp716[0..4 as usize]).map_err(|e| Error::EncodeError("ICMPTimestamp::transmit",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPParameterProblem<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp728 = <[u8; 1]>::default();
        (tmp728)[0 as usize] = self.pointer;
        w.write_all(&tmp728[0..1 as usize]).map_err(|e| Error::EncodeError("ICMPParameterProblem::pointer",e))?;
        let mut tmp734 = <[u8; 3]>::default();
        let mut tmp735 = 0;
        while((tmp735 < 3)) {
            (tmp734)[tmp735 as usize] = (((self.unused >> ((2 - tmp735) * 8)) & 255) as u8);
            tmp735+= 1;
        }
        w.write_all(&tmp734[0..3 as usize]).map_err(|e| Error::EncodeError("ICMPParameterProblem::unused",e))?;
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("ICMPParameterProblem::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
impl <'a>ICMPv4Packet<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.header.decode(r)?;
        let mut tmp380 = ICMPv4Type::from(self.header.type_);
        if (tmp380 == ICMPv4Type::echo) {
            if !matches!(self.field6,Variant7::Variant8(_)) {
                self.field6 = Variant7::Variant8(Variant8::default());
            }
            match &mut self.field6 {  Variant7::Variant8(x) => x, _ => unreachable!() }.echo.decode(r)?;
        } else if((tmp380 == ICMPv4Type::echo_reply)) {
            if !matches!(self.field6,Variant7::Variant12(_)) {
                self.field6 = Variant7::Variant12(Variant12::default());
            }
            match &mut self.field6 {  Variant7::Variant12(x) => x, _ => unreachable!() }.echo_reply.decode(r)?;
        } else if((tmp380 == ICMPv4Type::time_exceeded)) {
            if !matches!(self.field6,Variant7::Variant14(_)) {
                self.field6 = Variant7::Variant14(Variant14::default());
            }
            match &mut self.field6 {  Variant7::Variant14(x) => x, _ => unreachable!() }.time_exceeded.decode(r)?;
        } else if((tmp380 == ICMPv4Type::dst_unreachable)) {
            if !matches!(self.field6,Variant7::Variant18(_)) {
                self.field6 = Variant7::Variant18(Variant18::default());
            }
            match &mut self.field6 {  Variant7::Variant18(x) => x, _ => unreachable!() }.destination_unreachable.decode(r)?;
        } else if((tmp380 == ICMPv4Type::redirect)) {
            if !matches!(self.field6,Variant7::Variant22(_)) {
                self.field6 = Variant7::Variant22(Variant22::default());
            }
            match &mut self.field6 {  Variant7::Variant22(x) => x, _ => unreachable!() }.redirect.decode(r)?;
        } else if((tmp380 == ICMPv4Type::parameter_problem)) {
            if !matches!(self.field6,Variant7::Variant26(_)) {
                self.field6 = Variant7::Variant26(Variant26::default());
            }
            match &mut self.field6 {  Variant7::Variant26(x) => x, _ => unreachable!() }.parameter_problem.decode(r)?;
        } else if((tmp380 == ICMPv4Type::timestamp)) {
            if !matches!(self.field6,Variant7::Variant30(_)) {
                self.field6 = Variant7::Variant30(Variant30::default());
            }
            match &mut self.field6 {  Variant7::Variant30(x) => x, _ => unreachable!() }.timestamp.decode(r)?;
        } else if((tmp380 == ICMPv4Type::timestamp_reply)) {
            if !matches!(self.field6,Variant7::Variant34(_)) {
                self.field6 = Variant7::Variant34(Variant34::default());
            }
            match &mut self.field6 {  Variant7::Variant34(x) => x, _ => unreachable!() }.timestamp_reply.decode(r)?;
        } else {
            if !matches!(self.field6,Variant7::Variant36(_)) {
                self.field6 = Variant7::Variant36(Variant36::default());
            }
            r.read_to_end(match &mut self.field6 {  Variant7::Variant36(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::DecodeError("ICMPv4Packet::Variant7::Variant36::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp746 = <[u8; 1]>::default();
        r.read_exact(&mut tmp746[0..1 as usize]).map_err(|e| Error::DecodeError("ICMPHeader::type_",e))?;
        self.type_ = (tmp746)[0 as usize];
        let mut tmp751 = <[u8; 1]>::default();
        r.read_exact(&mut tmp751[0..1 as usize]).map_err(|e| Error::DecodeError("ICMPHeader::code",e))?;
        self.code = (tmp751)[0 as usize];
        let mut tmp756 = <[u8; 2]>::default();
        r.read_exact(&mut tmp756[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPHeader::checksum",e))?;
        let mut tmp757 = 0;
        while((tmp757 < 2)) {
            self.checksum = (self.checksum | (((tmp756)[tmp757 as usize] as u16) << ((1 - tmp757) * 8)));
            tmp757+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPTimeExceeded<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp768 = <[u8; 4]>::default();
        r.read_exact(&mut tmp768[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPTimeExceeded::unused",e))?;
        let mut tmp769 = 0;
        while((tmp769 < 4)) {
            self.unused = (self.unused | (((tmp768)[tmp769 as usize] as u32) << ((3 - tmp769) * 8)));
            tmp769+= 1;
        }
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPTimeExceeded::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPEcho<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp780 = <[u8; 2]>::default();
        r.read_exact(&mut tmp780[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPEcho::id",e))?;
        let mut tmp781 = 0;
        while((tmp781 < 2)) {
            self.id = (self.id | (((tmp780)[tmp781 as usize] as u16) << ((1 - tmp781) * 8)));
            tmp781+= 1;
        }
        let mut tmp792 = <[u8; 2]>::default();
        r.read_exact(&mut tmp792[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPEcho::seq",e))?;
        let mut tmp793 = 0;
        while((tmp793 < 2)) {
            self.seq = (self.seq | (((tmp792)[tmp793 as usize] as u16) << ((1 - tmp793) * 8)));
            tmp793+= 1;
        }
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPEcho::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPDestinationUnreachable<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp804 = <[u8; 2]>::default();
        r.read_exact(&mut tmp804[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPDestinationUnreachable::unused",e))?;
        let mut tmp805 = 0;
        while((tmp805 < 2)) {
            self.unused = (self.unused | (((tmp804)[tmp805 as usize] as u16) << ((1 - tmp805) * 8)));
            tmp805+= 1;
        }
        let mut tmp816 = <[u8; 2]>::default();
        r.read_exact(&mut tmp816[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPDestinationUnreachable::next_hop_mtu",e))?;
        let mut tmp817 = 0;
        while((tmp817 < 2)) {
            self.next_hop_mtu = (self.next_hop_mtu | (((tmp816)[tmp817 as usize] as u16) << ((1 - tmp817) * 8)));
            tmp817+= 1;
        }
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPDestinationUnreachable::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPPacketTooBig<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp828 = <[u8; 4]>::default();
        r.read_exact(&mut tmp828[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPPacketTooBig::unused",e))?;
        let mut tmp829 = 0;
        while((tmp829 < 4)) {
            self.unused = (self.unused | (((tmp828)[tmp829 as usize] as u32) << ((3 - tmp829) * 8)));
            tmp829+= 1;
        }
        let mut tmp840 = <[u8; 4]>::default();
        r.read_exact(&mut tmp840[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPPacketTooBig::mtu",e))?;
        let mut tmp841 = 0;
        while((tmp841 < 4)) {
            self.mtu = (self.mtu | (((tmp840)[tmp841 as usize] as u32) << ((3 - tmp841) * 8)));
            tmp841+= 1;
        }
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPPacketTooBig::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>ICMPRedirect<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.gateway[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPRedirect::gateway",e))?;
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPRedirect::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPTimestamp<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp852 = <[u8; 2]>::default();
        r.read_exact(&mut tmp852[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPTimestamp::id",e))?;
        let mut tmp853 = 0;
        while((tmp853 < 2)) {
            self.id = (self.id | (((tmp852)[tmp853 as usize] as u16) << ((1 - tmp853) * 8)));
            tmp853+= 1;
        }
        let mut tmp864 = <[u8; 2]>::default();
        r.read_exact(&mut tmp864[0..2 as usize]).map_err(|e| Error::DecodeError("ICMPTimestamp::seq",e))?;
        let mut tmp865 = 0;
        while((tmp865 < 2)) {
            self.seq = (self.seq | (((tmp864)[tmp865 as usize] as u16) << ((1 - tmp865) * 8)));
            tmp865+= 1;
        }
        let mut tmp876 = <[u8; 4]>::default();
        r.read_exact(&mut tmp876[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPTimestamp::originate",e))?;
        let mut tmp877 = 0;
        while((tmp877 < 4)) {
            self.originate = (self.originate | (((tmp876)[tmp877 as usize] as u32) << ((3 - tmp877) * 8)));
            tmp877+= 1;
        }
        let mut tmp888 = <[u8; 4]>::default();
        r.read_exact(&mut tmp888[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPTimestamp::receive",e))?;
        let mut tmp889 = 0;
        while((tmp889 < 4)) {
            self.receive = (self.receive | (((tmp888)[tmp889 as usize] as u32) << ((3 - tmp889) * 8)));
            tmp889+= 1;
        }
        let mut tmp900 = <[u8; 4]>::default();
        r.read_exact(&mut tmp900[0..4 as usize]).map_err(|e| Error::DecodeError("ICMPTimestamp::transmit",e))?;
        let mut tmp901 = 0;
        while((tmp901 < 4)) {
            self.transmit = (self.transmit | (((tmp900)[tmp901 as usize] as u32) << ((3 - tmp901) * 8)));
            tmp901+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ICMPParameterProblem<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp912 = <[u8; 1]>::default();
        r.read_exact(&mut tmp912[0..1 as usize]).map_err(|e| Error::DecodeError("ICMPParameterProblem::pointer",e))?;
        self.pointer = (tmp912)[0 as usize];
        let mut tmp917 = <[u8; 3]>::default();
        r.read_exact(&mut tmp917[0..3 as usize]).map_err(|e| Error::DecodeError("ICMPParameterProblem::unused",e))?;
        let mut tmp918 = 0;
        while((tmp918 < 3)) {
            self.unused = (self.unused | (((tmp917)[tmp918 as usize] as u32) << ((2 - tmp918) * 8)));
            tmp918+= 1;
        }
        r.read_to_end(self.data.to_mut()).map_err(|e| Error::DecodeError("ICMPParameterProblem::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn data(&self) -> std::option::Option<&std::borrow::Cow<'a,[u8]>> {
        let mut tmp47 = ICMPv4Type::from(self.header.type_);
        if ((tmp47 == ICMPv4Type::echo) || ((tmp47 == ICMPv4Type::echo_reply) || ((tmp47 == ICMPv4Type::time_exceeded) || ((tmp47 == ICMPv4Type::dst_unreachable) || ((tmp47 == ICMPv4Type::redirect) || ((tmp47 == ICMPv4Type::parameter_problem) || ((tmp47 == ICMPv4Type::timestamp) || (tmp47 == ICMPv4Type::timestamp_reply)))))))) {
            return None;
        }
        if true {
            if !matches!(self.field6,Variant7::Variant36(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant36(x) => x, _ => unreachable!() }.data);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_data(&mut self, param450: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        let mut tmp47 = ICMPv4Type::from(self.header.type_);
        if ((tmp47 == ICMPv4Type::echo) || ((tmp47 == ICMPv4Type::echo_reply) || ((tmp47 == ICMPv4Type::time_exceeded) || ((tmp47 == ICMPv4Type::dst_unreachable) || ((tmp47 == ICMPv4Type::redirect) || ((tmp47 == ICMPv4Type::parameter_problem) || ((tmp47 == ICMPv4Type::timestamp) || (tmp47 == ICMPv4Type::timestamp_reply)))))))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::data"));
        }
        if true {
            if !matches!(self.field6,Variant7::Variant36(_)) {
                self.field6 = Variant7::Variant36(Variant36::default());
            }
            match &mut self.field6 {  Variant7::Variant36(x) => x, _ => unreachable!() }.data = param450;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::data"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn destination_unreachable(&self) -> std::option::Option<&ICMPDestinationUnreachable<'a>> {
        let mut tmp94 = ICMPv4Type::from(self.header.type_);
        if ((tmp94 == ICMPv4Type::echo) || ((tmp94 == ICMPv4Type::echo_reply) || (tmp94 == ICMPv4Type::time_exceeded))) {
            return None;
        }
        if (tmp94 == ICMPv4Type::dst_unreachable) {
            if !matches!(self.field6,Variant7::Variant18(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant18(x) => x, _ => unreachable!() }.destination_unreachable);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_destination_unreachable(&mut self, param467: ICMPDestinationUnreachable<'a>) -> std::result::Result<(), Error> {
        let mut tmp94 = ICMPv4Type::from(self.header.type_);
        if ((tmp94 == ICMPv4Type::echo) || ((tmp94 == ICMPv4Type::echo_reply) || (tmp94 == ICMPv4Type::time_exceeded))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::destination_unreachable"));
        }
        if (tmp94 == ICMPv4Type::dst_unreachable) {
            if !matches!(self.field6,Variant7::Variant18(_)) {
                self.field6 = Variant7::Variant18(Variant18::default());
            }
            match &mut self.field6 {  Variant7::Variant18(x) => x, _ => unreachable!() }.destination_unreachable = param467;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::destination_unreachable"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn echo(&self) -> std::option::Option<&ICMPEcho<'a>> {
        let mut tmp115 = ICMPv4Type::from(self.header.type_);
        if (tmp115 == ICMPv4Type::echo) {
            if !matches!(self.field6,Variant7::Variant8(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant8(x) => x, _ => unreachable!() }.echo);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_echo(&mut self, param475: ICMPEcho<'a>) -> std::result::Result<(), Error> {
        let mut tmp115 = ICMPv4Type::from(self.header.type_);
        if (tmp115 == ICMPv4Type::echo) {
            if !matches!(self.field6,Variant7::Variant8(_)) {
                self.field6 = Variant7::Variant8(Variant8::default());
            }
            match &mut self.field6 {  Variant7::Variant8(x) => x, _ => unreachable!() }.echo = param475;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::echo"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn echo_reply(&self) -> std::option::Option<&ICMPEcho<'a>> {
        let mut tmp124 = ICMPv4Type::from(self.header.type_);
        if (tmp124 == ICMPv4Type::echo) {
            return None;
        }
        if (tmp124 == ICMPv4Type::echo_reply) {
            if !matches!(self.field6,Variant7::Variant12(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant12(x) => x, _ => unreachable!() }.echo_reply);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_echo_reply(&mut self, param481: ICMPEcho<'a>) -> std::result::Result<(), Error> {
        let mut tmp124 = ICMPv4Type::from(self.header.type_);
        if (tmp124 == ICMPv4Type::echo) {
            return Err(Error::PropertySetterError("ICMPv4Packet::echo_reply"));
        }
        if (tmp124 == ICMPv4Type::echo_reply) {
            if !matches!(self.field6,Variant7::Variant12(_)) {
                self.field6 = Variant7::Variant12(Variant12::default());
            }
            match &mut self.field6 {  Variant7::Variant12(x) => x, _ => unreachable!() }.echo_reply = param481;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::echo_reply"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn parameter_problem(&self) -> std::option::Option<&ICMPParameterProblem<'a>> {
        let mut tmp137 = ICMPv4Type::from(self.header.type_);
        if ((tmp137 == ICMPv4Type::echo) || ((tmp137 == ICMPv4Type::echo_reply) || ((tmp137 == ICMPv4Type::time_exceeded) || ((tmp137 == ICMPv4Type::dst_unreachable) || (tmp137 == ICMPv4Type::redirect))))) {
            return None;
        }
        if (tmp137 == ICMPv4Type::parameter_problem) {
            if !matches!(self.field6,Variant7::Variant26(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant26(x) => x, _ => unreachable!() }.parameter_problem);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_parameter_problem(&mut self, param492: ICMPParameterProblem<'a>) -> std::result::Result<(), Error> {
        let mut tmp137 = ICMPv4Type::from(self.header.type_);
        if ((tmp137 == ICMPv4Type::echo) || ((tmp137 == ICMPv4Type::echo_reply) || ((tmp137 == ICMPv4Type::time_exceeded) || ((tmp137 == ICMPv4Type::dst_unreachable) || (tmp137 == ICMPv4Type::redirect))))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::parameter_problem"));
        }
        if (tmp137 == ICMPv4Type::parameter_problem) {
            if !matches!(self.field6,Variant7::Variant26(_)) {
                self.field6 = Variant7::Variant26(Variant26::default());
            }
            match &mut self.field6 {  Variant7::Variant26(x) => x, _ => unreachable!() }.parameter_problem = param492;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::parameter_problem"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn redirect(&self) -> std::option::Option<&ICMPRedirect<'a>> {
        let mut tmp166 = ICMPv4Type::from(self.header.type_);
        if ((tmp166 == ICMPv4Type::echo) || ((tmp166 == ICMPv4Type::echo_reply) || ((tmp166 == ICMPv4Type::time_exceeded) || (tmp166 == ICMPv4Type::dst_unreachable)))) {
            return None;
        }
        if (tmp166 == ICMPv4Type::redirect) {
            if !matches!(self.field6,Variant7::Variant22(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant22(x) => x, _ => unreachable!() }.redirect);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_redirect(&mut self, param506: ICMPRedirect<'a>) -> std::result::Result<(), Error> {
        let mut tmp166 = ICMPv4Type::from(self.header.type_);
        if ((tmp166 == ICMPv4Type::echo) || ((tmp166 == ICMPv4Type::echo_reply) || ((tmp166 == ICMPv4Type::time_exceeded) || (tmp166 == ICMPv4Type::dst_unreachable)))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::redirect"));
        }
        if (tmp166 == ICMPv4Type::redirect) {
            if !matches!(self.field6,Variant7::Variant22(_)) {
                self.field6 = Variant7::Variant22(Variant22::default());
            }
            match &mut self.field6 {  Variant7::Variant22(x) => x, _ => unreachable!() }.redirect = param506;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::redirect"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn time_exceeded(&self) -> std::option::Option<&ICMPTimeExceeded<'a>> {
        let mut tmp191 = ICMPv4Type::from(self.header.type_);
        if ((tmp191 == ICMPv4Type::echo) || (tmp191 == ICMPv4Type::echo_reply)) {
            return None;
        }
        if (tmp191 == ICMPv4Type::time_exceeded) {
            if !matches!(self.field6,Variant7::Variant14(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant14(x) => x, _ => unreachable!() }.time_exceeded);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_time_exceeded(&mut self, param517: ICMPTimeExceeded<'a>) -> std::result::Result<(), Error> {
        let mut tmp191 = ICMPv4Type::from(self.header.type_);
        if ((tmp191 == ICMPv4Type::echo) || (tmp191 == ICMPv4Type::echo_reply)) {
            return Err(Error::PropertySetterError("ICMPv4Packet::time_exceeded"));
        }
        if (tmp191 == ICMPv4Type::time_exceeded) {
            if !matches!(self.field6,Variant7::Variant14(_)) {
                self.field6 = Variant7::Variant14(Variant14::default());
            }
            match &mut self.field6 {  Variant7::Variant14(x) => x, _ => unreachable!() }.time_exceeded = param517;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::time_exceeded"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn timestamp(&self) -> std::option::Option<&ICMPTimestamp<'a>> {
        let mut tmp208 = ICMPv4Type::from(self.header.type_);
        if ((tmp208 == ICMPv4Type::echo) || ((tmp208 == ICMPv4Type::echo_reply) || ((tmp208 == ICMPv4Type::time_exceeded) || ((tmp208 == ICMPv4Type::dst_unreachable) || ((tmp208 == ICMPv4Type::redirect) || (tmp208 == ICMPv4Type::parameter_problem)))))) {
            return None;
        }
        if (tmp208 == ICMPv4Type::timestamp) {
            if !matches!(self.field6,Variant7::Variant30(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant30(x) => x, _ => unreachable!() }.timestamp);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_timestamp(&mut self, param530: ICMPTimestamp<'a>) -> std::result::Result<(), Error> {
        let mut tmp208 = ICMPv4Type::from(self.header.type_);
        if ((tmp208 == ICMPv4Type::echo) || ((tmp208 == ICMPv4Type::echo_reply) || ((tmp208 == ICMPv4Type::time_exceeded) || ((tmp208 == ICMPv4Type::dst_unreachable) || ((tmp208 == ICMPv4Type::redirect) || (tmp208 == ICMPv4Type::parameter_problem)))))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::timestamp"));
        }
        if (tmp208 == ICMPv4Type::timestamp) {
            if !matches!(self.field6,Variant7::Variant30(_)) {
                self.field6 = Variant7::Variant30(Variant30::default());
            }
            match &mut self.field6 {  Variant7::Variant30(x) => x, _ => unreachable!() }.timestamp = param530;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::timestamp"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn timestamp_reply(&self) -> std::option::Option<&ICMPTimestamp<'a>> {
        let mut tmp241 = ICMPv4Type::from(self.header.type_);
        if ((tmp241 == ICMPv4Type::echo) || ((tmp241 == ICMPv4Type::echo_reply) || ((tmp241 == ICMPv4Type::time_exceeded) || ((tmp241 == ICMPv4Type::dst_unreachable) || ((tmp241 == ICMPv4Type::redirect) || ((tmp241 == ICMPv4Type::parameter_problem) || (tmp241 == ICMPv4Type::timestamp))))))) {
            return None;
        }
        if (tmp241 == ICMPv4Type::timestamp_reply) {
            if !matches!(self.field6,Variant7::Variant34(_)) {
                return None;
            }
            return Some(&match &self.field6 {  Variant7::Variant34(x) => x, _ => unreachable!() }.timestamp_reply);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>ICMPv4Packet<'a> {
    pub fn set_timestamp_reply(&mut self, param547: ICMPTimestamp<'a>) -> std::result::Result<(), Error> {
        let mut tmp241 = ICMPv4Type::from(self.header.type_);
        if ((tmp241 == ICMPv4Type::echo) || ((tmp241 == ICMPv4Type::echo_reply) || ((tmp241 == ICMPv4Type::time_exceeded) || ((tmp241 == ICMPv4Type::dst_unreachable) || ((tmp241 == ICMPv4Type::redirect) || ((tmp241 == ICMPv4Type::parameter_problem) || (tmp241 == ICMPv4Type::timestamp))))))) {
            return Err(Error::PropertySetterError("ICMPv4Packet::timestamp_reply"));
        }
        if (tmp241 == ICMPv4Type::timestamp_reply) {
            if !matches!(self.field6,Variant7::Variant34(_)) {
                self.field6 = Variant7::Variant34(Variant34::default());
            }
            match &mut self.field6 {  Variant7::Variant34(x) => x, _ => unreachable!() }.timestamp_reply = param547;
            return Ok(());
        }
        return Err(Error::PropertySetterError("ICMPv4Packet::timestamp_reply"));
    }
}

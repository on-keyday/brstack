// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
/* Unimplemented op: IMMEDIATE_STRING */
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct TCPOptionKind(u8);
impl TCPOptionKind  {
    pub const END_OF_OPTIONS_LIST:Self = Self(0);
    pub const NOP:Self = Self(1);
    pub const MAXIMUM_SEGMENT_SIZE:Self = Self(2);
    pub const WINDOW_SCALE:Self = Self(3);
    pub const SACK_PERMITTED:Self = Self(4);
    pub const SACK:Self = Self(5);
    pub const TIMESTAMP:Self = Self(8);
    pub const MPTCP:Self = Self(30);
}
impl std::fmt::Display for TCPOptionKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TCPOptionKind::END_OF_OPTIONS_LIST => write!(f, "{}", "END_OF_OPTIONS_LIST"),
            TCPOptionKind::NOP => write!(f, "{}", "NOP"),
            TCPOptionKind::MAXIMUM_SEGMENT_SIZE => write!(f, "{}", "MAXIMUM_SEGMENT_SIZE"),
            TCPOptionKind::WINDOW_SCALE => write!(f, "{}", "WINDOW_SCALE"),
            TCPOptionKind::SACK_PERMITTED => write!(f, "{}", "SACK_PERMITTED"),
            TCPOptionKind::SACK => write!(f, "{}", "SACK"),
            TCPOptionKind::TIMESTAMP => write!(f, "{}", "TIMESTAMP"),
            TCPOptionKind::MPTCP => write!(f, "{}", "MPTCP"),
            _ => write!(f, "TCPOptionKind({})",self.0),
        }
    }
}
impl std::convert::From<TCPOptionKind> for std::option::Option<&str> {
    fn from(e: TCPOptionKind) -> Self {
        match e {
            TCPOptionKind::END_OF_OPTIONS_LIST => Some("END_OF_OPTIONS_LIST"),
            TCPOptionKind::NOP => Some("NOP"),
            TCPOptionKind::MAXIMUM_SEGMENT_SIZE => Some("MAXIMUM_SEGMENT_SIZE"),
            TCPOptionKind::WINDOW_SCALE => Some("WINDOW_SCALE"),
            TCPOptionKind::SACK_PERMITTED => Some("SACK_PERMITTED"),
            TCPOptionKind::SACK => Some("SACK"),
            TCPOptionKind::TIMESTAMP => Some("TIMESTAMP"),
            TCPOptionKind::MPTCP => Some("MPTCP"),
            _ =>  None,
        }
    }
}
impl TCPOptionKind {
    pub fn is_known(&self) -> bool {
        match *self {
            TCPOptionKind::END_OF_OPTIONS_LIST => true,
            TCPOptionKind::NOP => true,
            TCPOptionKind::MAXIMUM_SEGMENT_SIZE => true,
            TCPOptionKind::WINDOW_SCALE => true,
            TCPOptionKind::SACK_PERMITTED => true,
            TCPOptionKind::SACK => true,
            TCPOptionKind::TIMESTAMP => true,
            TCPOptionKind::MPTCP => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for TCPOptionKind {
    fn from(e: u8) -> Self {
        Self(e)
    }
}
impl std::convert::From<TCPOptionKind> for u8 {
    fn from(e: TCPOptionKind) -> Self {
        e.0
    }
}
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl <'a>TCPHeaderFixed<'a> {
    pub fn dataOffset(&self) -> u8 {
        ((self.field_5>>4) & 15) as u8}
    pub fn set_dataOffset(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_5 = self.field_5& !(15<< 4) | ((value as u8) << 4);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn reserved(&self) -> u8 {
        ((self.field_5>>0) & 15) as u8}
    pub fn set_reserved(&mut self, value: u8) -> bool {
        if value > 15 {
        return false;
        }
        self.field_5 = self.field_5& !(15<< 0) | ((value as u8) << 0);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn CWR(&self) -> bool {
        ((self.field_6>>7) & 1) as u8 != 0}
    pub fn set_CWR(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 7) | ((if value {1} else {0} as u8) << 7);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn ECE(&self) -> bool {
        ((self.field_6>>6) & 1) as u8 != 0}
    pub fn set_ECE(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 6) | ((if value {1} else {0} as u8) << 6);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn URG(&self) -> bool {
        ((self.field_6>>5) & 1) as u8 != 0}
    pub fn set_URG(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 5) | ((if value {1} else {0} as u8) << 5);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn ACK(&self) -> bool {
        ((self.field_6>>4) & 1) as u8 != 0}
    pub fn set_ACK(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 4) | ((if value {1} else {0} as u8) << 4);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn PSH(&self) -> bool {
        ((self.field_6>>3) & 1) as u8 != 0}
    pub fn set_PSH(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 3) | ((if value {1} else {0} as u8) << 3);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn RST(&self) -> bool {
        ((self.field_6>>2) & 1) as u8 != 0}
    pub fn set_RST(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 2) | ((if value {1} else {0} as u8) << 2);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn SYN(&self) -> bool {
        ((self.field_6>>1) & 1) as u8 != 0}
    pub fn set_SYN(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 1) | ((if value {1} else {0} as u8) << 1);
        true
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn FIN(&self) -> bool {
        ((self.field_6>>0) & 1) as u8 != 0}
    pub fn set_FIN(&mut self, value: bool) -> bool {
        self.field_6 = self.field_6& !(1<< 0) | ((if value {1} else {0} as u8) << 0);
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant61<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant62<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant63<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
    pub mss: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant66<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
    pub shiftCount: u8,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant69<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant71<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
    pub sack: Sack<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant76<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
    pub timestamp: Timestamp<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
struct Variant81<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    pub length: u8,
    pub data: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
enum Variant60<'a> {
    #[default]
    None,
    Variant61(Variant61<'a>),
    Variant62(Variant62<'a>),
    Variant63(Variant63<'a>),
    Variant66(Variant66<'a>),
    Variant69(Variant69<'a>),
    Variant71(Variant71<'a>),
    Variant76(Variant76<'a>),
    Variant81(Variant81<'a>),
}
/* Unimplemented op: IMMEDIATE_STRING */
/* Unimplemented op: METADATA */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct TCPHeaderFixed<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub src_port: u16,
    pub dst_port: u16,
    pub seq_num: u32,
    pub ack_num: u32,
    field_5 :u8,/*dataOffset :4*/
    /*reserved :4*/
    
    
    field_6 :u8,/*CWR :1*/
    /*ECE :1*/
    /*URG :1*/
    /*ACK :1*/
    /*PSH :1*/
    /*RST :1*/
    /*SYN :1*/
    /*FIN :1*/
    
    
    
    
    
    
    
    
    pub window_size: u16,
    pub checksum: u16,
    pub urgent_pointer: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct SackBlock<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub left: u32,
    pub right: u32,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Timestamp<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub value: u32,
    pub echoReply: u32,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Sack<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub blocks: std::borrow::Cow<'a,[SackBlock<'a>]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct TCPOption<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub kind: TCPOptionKind,
    pub field59: Variant60<'a>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct TCPHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hdr: TCPHeaderFixed<'a>,
    pub options: std::borrow::Cow<'a,[TCPOption<'a>]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct TCPSegment<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub hdr: TCPHeader<'a>,
    pub payload: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>TCPHeaderFixed<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp822 = <[u8; 2]>::default();
        let mut tmp823 = 0;
        while((tmp823 < 2)) {
            (tmp822)[tmp823 as usize] = (((self.src_port >> ((1 - tmp823) * 8)) & 255) as u8);
            tmp823+= 1;
        }
        w.write_all(&tmp822[0..2 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::src_port",e))?;
        let mut tmp835 = <[u8; 2]>::default();
        let mut tmp836 = 0;
        while((tmp836 < 2)) {
            (tmp835)[tmp836 as usize] = (((self.dst_port >> ((1 - tmp836) * 8)) & 255) as u8);
            tmp836+= 1;
        }
        w.write_all(&tmp835[0..2 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::dst_port",e))?;
        let mut tmp848 = <[u8; 4]>::default();
        let mut tmp849 = 0;
        while((tmp849 < 4)) {
            (tmp848)[tmp849 as usize] = (((self.seq_num >> ((3 - tmp849) * 8)) & 255) as u8);
            tmp849+= 1;
        }
        w.write_all(&tmp848[0..4 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::seq_num",e))?;
        let mut tmp860 = <[u8; 4]>::default();
        let mut tmp861 = 0;
        while((tmp861 < 4)) {
            (tmp860)[tmp861 as usize] = (((self.ack_num >> ((3 - tmp861) * 8)) & 255) as u8);
            tmp861+= 1;
        }
        w.write_all(&tmp860[0..4 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::ack_num",e))?;
        let mut tmp631 = <u8>::default();
        let mut tmp632 = 0;
        tmp632 = (tmp632 + 4);
        tmp631 = (tmp631 | (((self.dataOffset() as u8) & 15) << (8 - tmp632)));
        tmp632 = (tmp632 + 4);
        tmp631 = (tmp631 | (((self.reserved() as u8) & 15) << (8 - tmp632)));
        let mut tmp1193 = <[u8; 1]>::default();
        (tmp1193)[0 as usize] = tmp631;
        w.write_all(&tmp1193[0..1 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::bit_field_dataOffset_reserved",e))?;
        let mut tmp654 = <u8>::default();
        let mut tmp655 = 0;
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.CWR() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.ECE() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.URG() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.ACK() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.PSH() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.RST() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.SYN() {1} else {0} & 1) << (8 - tmp655)));
        tmp655 = (tmp655 + 1);
        tmp654 = (tmp654 | ((if self.FIN() {1} else {0} & 1) << (8 - tmp655)));
        let mut tmp1198 = <[u8; 1]>::default();
        (tmp1198)[0 as usize] = tmp654;
        w.write_all(&tmp1198[0..1 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::bit_field_CWR_ECE_URG_ACK_PSH_RST_SYN_FIN",e))?;
        let mut tmp872 = <[u8; 2]>::default();
        let mut tmp873 = 0;
        while((tmp873 < 2)) {
            (tmp872)[tmp873 as usize] = (((self.window_size >> ((1 - tmp873) * 8)) & 255) as u8);
            tmp873+= 1;
        }
        w.write_all(&tmp872[0..2 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::window_size",e))?;
        let mut tmp884 = <[u8; 2]>::default();
        let mut tmp885 = 0;
        while((tmp885 < 2)) {
            (tmp884)[tmp885 as usize] = (((self.checksum >> ((1 - tmp885) * 8)) & 255) as u8);
            tmp885+= 1;
        }
        w.write_all(&tmp884[0..2 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::checksum",e))?;
        let mut tmp896 = <[u8; 2]>::default();
        let mut tmp897 = 0;
        while((tmp897 < 2)) {
            (tmp896)[tmp897 as usize] = (((self.urgent_pointer >> ((1 - tmp897) * 8)) & 255) as u8);
            tmp897+= 1;
        }
        w.write_all(&tmp896[0..2 as usize]).map_err(|e| Error::EncodeError("TCPHeaderFixed::urgent_pointer",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>TCPHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.hdr.encode(w)?;
        let mut tmp_array263 = Vec::with_capacity((((self.hdr.dataOffset() * 4) as u8) - 20) as usize);
        let mut cursor263 = std::io::Cursor::new(&mut tmp_array263);
        let mut tmp265 = 0;
        while((tmp265 < self.options.len())) {
            (self.options)[tmp265 as usize].encode(&mut cursor263)?;
            tmp265+= 1;
        }
        if tmp_array263.len() != (((self.hdr.dataOffset() * 4) as u8) - 20) as usize {
            return Err(Error::ArrayLengthMismatch("encode tmp_array263",(((self.hdr.dataOffset() * 4) as u8) - 20) as usize,tmp_array263.len()));
        }
        w.write_all(&tmp_array263).map_err(|e| Error::EncodeError("",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>TCPSegment<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.hdr.encode(w)?;
        w.write_all(&self.payload[0..self.payload.len() as usize]).map_err(|e| Error::EncodeError("TCPSegment::payload",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>TCPOption<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp909 = <[u8; 1]>::default();
        (tmp909)[0 as usize] = u8::from(self.kind);
        w.write_all(&tmp909[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::kind",e))?;
        let mut tmp273 = self.kind;
        if (tmp273 == TCPOptionKind::END_OF_OPTIONS_LIST) {
        } else if((tmp273 == TCPOptionKind::NOP)) {
        } else if((tmp273 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE)) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant63"));
            }
            let mut tmp914 = <[u8; 1]>::default();
            (tmp914)[0 as usize] = match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp914[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant63::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)"));
            }
            let mut tmp919 = <[u8; 2]>::default();
            let mut tmp920 = 0;
            while((tmp920 < 2)) {
                (tmp919)[tmp920 as usize] = (((match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss >> ((1 - tmp920) * 8)) & 255) as u8);
                tmp920+= 1;
            }
            w.write_all(&tmp919[0..2 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant63::mss",e))?;
        } else if((tmp273 == TCPOptionKind::WINDOW_SCALE)) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant66"));
            }
            let mut tmp931 = <[u8; 1]>::default();
            (tmp931)[0 as usize] = match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp931[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant66::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)"));
            }
            let mut tmp936 = <[u8; 1]>::default();
            (tmp936)[0 as usize] = match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.shiftCount;
            w.write_all(&tmp936[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant66::shiftCount",e))?;
        } else if((tmp273 == TCPOptionKind::SACK_PERMITTED)) {
            if !matches!(self.field59,Variant60::Variant69(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant69"));
            }
            let mut tmp941 = <[u8; 1]>::default();
            (tmp941)[0 as usize] = match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp941[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant69::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)"));
            }
        } else if((tmp273 == TCPOptionKind::SACK)) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant71"));
            }
            let mut tmp946 = <[u8; 1]>::default();
            (tmp946)[0 as usize] = match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp946[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant71::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            let mut tmp_array302 = Vec::with_capacity((match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize);
            let mut cursor302 = std::io::Cursor::new(&mut tmp_array302);
            match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.sack.encode(&mut cursor302)?;
            if tmp_array302.len() != (match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array302",(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize,tmp_array302.len()));
            }
            w.write_all(&tmp_array302).map_err(|e| Error::EncodeError("",e))?;
        } else if((tmp273 == TCPOptionKind::TIMESTAMP)) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant76"));
            }
            let mut tmp951 = <[u8; 1]>::default();
            (tmp951)[0 as usize] = match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp951[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant76::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)"));
            }
            let mut tmp_array309 = Vec::with_capacity((match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize);
            let mut cursor309 = std::io::Cursor::new(&mut tmp_array309);
            match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.timestamp.encode(&mut cursor309)?;
            if tmp_array309.len() != (match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize {
                return Err(Error::ArrayLengthMismatch("encode tmp_array309",(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize,tmp_array309.len()));
            }
            w.write_all(&tmp_array309).map_err(|e| Error::EncodeError("",e))?;
        } else {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                return Err(Error::InvalidUnionVariant("Variant60::Variant81"));
            }
            let mut tmp956 = <[u8; 1]>::default();
            (tmp956)[0 as usize] = match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length;
            w.write_all(&tmp956[0..1 as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant81::length",e))?;
            if(!(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            let mut tmp313 = (match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length - 2);
            if match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data.len() != tmp313 as usize {
            return Err(Error::ArrayLengthMismatch("encode TCPOption::Variant60::Variant81::data", tmp313 as usize, match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data.len()));
            }
            w.write_all(&match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data[0..match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data.len() as usize]).map_err(|e| Error::EncodeError("TCPOption::Variant60::Variant81::data",e))?;
        }
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>SackBlock<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp961 = <[u8; 4]>::default();
        let mut tmp962 = 0;
        while((tmp962 < 4)) {
            (tmp961)[tmp962 as usize] = (((self.left >> ((3 - tmp962) * 8)) & 255) as u8);
            tmp962+= 1;
        }
        w.write_all(&tmp961[0..4 as usize]).map_err(|e| Error::EncodeError("SackBlock::left",e))?;
        let mut tmp973 = <[u8; 4]>::default();
        let mut tmp974 = 0;
        while((tmp974 < 4)) {
            (tmp973)[tmp974 as usize] = (((self.right >> ((3 - tmp974) * 8)) & 255) as u8);
            tmp974+= 1;
        }
        w.write_all(&tmp973[0..4 as usize]).map_err(|e| Error::EncodeError("SackBlock::right",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>Sack<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp317 = 0;
        while((tmp317 < self.blocks.len())) {
            (self.blocks)[tmp317 as usize].encode(w)?;
            tmp317+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Timestamp<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp985 = <[u8; 4]>::default();
        let mut tmp986 = 0;
        while((tmp986 < 4)) {
            (tmp985)[tmp986 as usize] = (((self.value >> ((3 - tmp986) * 8)) & 255) as u8);
            tmp986+= 1;
        }
        w.write_all(&tmp985[0..4 as usize]).map_err(|e| Error::EncodeError("Timestamp::value",e))?;
        let mut tmp997 = <[u8; 4]>::default();
        let mut tmp998 = 0;
        while((tmp998 < 4)) {
            (tmp997)[tmp998 as usize] = (((self.echoReply >> ((3 - tmp998) * 8)) & 255) as u8);
            tmp998+= 1;
        }
        w.write_all(&tmp997[0..4 as usize]).map_err(|e| Error::EncodeError("Timestamp::echoReply",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>TCPHeaderFixed<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp1009 = <[u8; 2]>::default();
        r.read_exact(&mut tmp1009[0..2 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::src_port",e))?;
        let mut tmp1010 = 0;
        while((tmp1010 < 2)) {
            self.src_port = (self.src_port | (((tmp1009)[tmp1010 as usize] as u16) << ((1 - tmp1010) * 8)));
            tmp1010+= 1;
        }
        let mut tmp1021 = <[u8; 2]>::default();
        r.read_exact(&mut tmp1021[0..2 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::dst_port",e))?;
        let mut tmp1022 = 0;
        while((tmp1022 < 2)) {
            self.dst_port = (self.dst_port | (((tmp1021)[tmp1022 as usize] as u16) << ((1 - tmp1022) * 8)));
            tmp1022+= 1;
        }
        let mut tmp1033 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1033[0..4 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::seq_num",e))?;
        let mut tmp1034 = 0;
        while((tmp1034 < 4)) {
            self.seq_num = (self.seq_num | (((tmp1033)[tmp1034 as usize] as u32) << ((3 - tmp1034) * 8)));
            tmp1034+= 1;
        }
        let mut tmp1045 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1045[0..4 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::ack_num",e))?;
        let mut tmp1046 = 0;
        while((tmp1046 < 4)) {
            self.ack_num = (self.ack_num | (((tmp1045)[tmp1046 as usize] as u32) << ((3 - tmp1046) * 8)));
            tmp1046+= 1;
        }
        let mut tmp731 = <u8>::default();
        let mut tmp732 = 0;
        let mut tmp1203 = <[u8; 1]>::default();
        r.read_exact(&mut tmp1203[0..1 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::bit_field_dataOffset_reserved",e))?;
        tmp731 = (tmp1203)[0 as usize];
        tmp732 = (tmp732 + 4);
        self.set_dataOffset((((tmp731 >> (8 - tmp732)) & 15) as u8));
        tmp732 = (tmp732 + 4);
        self.set_reserved((((tmp731 >> (8 - tmp732)) & 15) as u8));
        let mut tmp752 = <u8>::default();
        let mut tmp753 = 0;
        let mut tmp1208 = <[u8; 1]>::default();
        r.read_exact(&mut tmp1208[0..1 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::bit_field_CWR_ECE_URG_ACK_PSH_RST_SYN_FIN",e))?;
        tmp752 = (tmp1208)[0 as usize];
        tmp753 = (tmp753 + 1);
        self.set_CWR(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_ECE(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_URG(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_ACK(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_PSH(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_RST(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_SYN(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_FIN(((tmp752 >> (8 - tmp753)) & 1) != 0);
        let mut tmp1057 = <[u8; 2]>::default();
        r.read_exact(&mut tmp1057[0..2 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::window_size",e))?;
        let mut tmp1058 = 0;
        while((tmp1058 < 2)) {
            self.window_size = (self.window_size | (((tmp1057)[tmp1058 as usize] as u16) << ((1 - tmp1058) * 8)));
            tmp1058+= 1;
        }
        let mut tmp1069 = <[u8; 2]>::default();
        r.read_exact(&mut tmp1069[0..2 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::checksum",e))?;
        let mut tmp1070 = 0;
        while((tmp1070 < 2)) {
            self.checksum = (self.checksum | (((tmp1069)[tmp1070 as usize] as u16) << ((1 - tmp1070) * 8)));
            tmp1070+= 1;
        }
        let mut tmp1081 = <[u8; 2]>::default();
        r.read_exact(&mut tmp1081[0..2 as usize]).map_err(|e| Error::DecodeError("TCPHeaderFixed::urgent_pointer",e))?;
        let mut tmp1082 = 0;
        while((tmp1082 < 2)) {
            self.urgent_pointer = (self.urgent_pointer | (((tmp1081)[tmp1082 as usize] as u16) << ((1 - tmp1082) * 8)));
            tmp1082+= 1;
        }
        return Ok(());
    }
}
impl <'a>TCPHeaderFixed<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp1009 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::src_port",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1009.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp1010 = 0;
        while((tmp1010 < 2)) {
            self.src_port = (self.src_port | (((tmp1009)[tmp1010 as usize] as u16) << ((1 - tmp1010) * 8)));
            tmp1010+= 1;
        }
        let mut tmp1021 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::dst_port",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1021.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp1022 = 0;
        while((tmp1022 < 2)) {
            self.dst_port = (self.dst_port | (((tmp1021)[tmp1022 as usize] as u16) << ((1 - tmp1022) * 8)));
            tmp1022+= 1;
        }
        let mut tmp1033 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::seq_num",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1033.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1034 = 0;
        while((tmp1034 < 4)) {
            self.seq_num = (self.seq_num | (((tmp1033)[tmp1034 as usize] as u32) << ((3 - tmp1034) * 8)));
            tmp1034+= 1;
        }
        let mut tmp1045 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::ack_num",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1045.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1046 = 0;
        while((tmp1046 < 4)) {
            self.ack_num = (self.ack_num | (((tmp1045)[tmp1046 as usize] as u32) << ((3 - tmp1046) * 8)));
            tmp1046+= 1;
        }
        let mut tmp731 = <u8>::default();
        let mut tmp732 = 0;
        let mut tmp1203 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::bit_field_dataOffset_reserved",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1203.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp731 = (tmp1203)[0 as usize];
        tmp732 = (tmp732 + 4);
        self.set_dataOffset((((tmp731 >> (8 - tmp732)) & 15) as u8));
        tmp732 = (tmp732 + 4);
        self.set_reserved((((tmp731 >> (8 - tmp732)) & 15) as u8));
        let mut tmp752 = <u8>::default();
        let mut tmp753 = 0;
        let mut tmp1208 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::bit_field_CWR_ECE_URG_ACK_PSH_RST_SYN_FIN",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1208.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp752 = (tmp1208)[0 as usize];
        tmp753 = (tmp753 + 1);
        self.set_CWR(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_ECE(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_URG(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_ACK(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_PSH(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_RST(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_SYN(((tmp752 >> (8 - tmp753)) & 1) != 0);
        tmp753 = (tmp753 + 1);
        self.set_FIN(((tmp752 >> (8 - tmp753)) & 1) != 0);
        let mut tmp1057 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::window_size",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1057.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp1058 = 0;
        while((tmp1058 < 2)) {
            self.window_size = (self.window_size | (((tmp1057)[tmp1058 as usize] as u16) << ((1 - tmp1058) * 8)));
            tmp1058+= 1;
        }
        let mut tmp1069 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::checksum",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1069.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp1070 = 0;
        while((tmp1070 < 2)) {
            self.checksum = (self.checksum | (((tmp1069)[tmp1070 as usize] as u16) << ((1 - tmp1070) * 8)));
            tmp1070+= 1;
        }
        let mut tmp1081 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeaderFixed::urgent_pointer",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1081.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp1082 = 0;
        while((tmp1082 < 2)) {
            self.urgent_pointer = (self.urgent_pointer | (((tmp1081)[tmp1082 as usize] as u16) << ((1 - tmp1082) * 8)));
            tmp1082+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>TCPHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
    use std::io::Read;
    use std::io::Seek;
    use std::io::BufRead;
        self.hdr.decode(r)?;
        let mut tmp_array328 :Vec<u8> = vec![0; (((self.hdr.dataOffset() * 4) as u8) - 20) as usize];
        r.read_exact(&mut tmp_array328).map_err(|e| Error::DecodeError("TCPHeader::options",e))?;
        let mut cursor328 = std::io::Cursor::new(&tmp_array328);
        while(cursor328.fill_buf().map(|b| !b.is_empty()).map_err(|e| Error::DecodeError("TCPHeader::options",e))?) {
            let mut tmp332 = <TCPOption<'a>>::default();
            tmp332.decode(&mut cursor328)?;
            self.options.to_mut().push(tmp332);
        }
        if cursor328.position() != (((self.hdr.dataOffset() * 4) as u8) - 20) as u64 {
            return Err(Error::ArrayLengthMismatch("encode ",(((self.hdr.dataOffset() * 4) as u8) - 20) as usize,cursor328.position() as usize));
        }
        return Ok(());
    }
}
impl <'a>TCPHeader<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        self.hdr.decode_direct(r, offset)?;
        if *offset + ((((self.hdr.dataOffset() * 4) as u8) - 20) as usize) > r.len() {
        return Err(Error::DecodeError("TCPHeader::options",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        let tmp_array328 = &r[*offset..(*offset + ((((self.hdr.dataOffset() * 4) as u8) - 20) as usize))];
        *offset += ((((self.hdr.dataOffset() * 4) as u8) - 20) as usize);
        let mut offset328 = 0;
        while((offset328 < tmp_array328.len())) {
            let mut tmp332 = <TCPOption<'a>>::default();
            tmp332.decode_direct(tmp_array328, &mut offset328)?;
            self.options.to_mut().push(tmp332);
        }
        if offset328 != ((((self.hdr.dataOffset() * 4) as u8) - 20) as usize) {
            return Err(Error::ArrayLengthMismatch("decode ",(((self.hdr.dataOffset() * 4) as u8) - 20) as usize,offset328 as usize));
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>TCPSegment<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.hdr.decode(r)?;
        r.read_to_end(self.payload.to_mut()).map_err(|e| Error::DecodeError("TCPSegment::payload",e))?;
        return Ok(());
    }
}
impl <'a>TCPSegment<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        self.hdr.decode_direct(r, offset)?;
        self.payload = std::borrow::Cow::Borrowed(&r[*offset..]);
        *offset = r.len();
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_COND_BLOCK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>TCPOption<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
    use std::io::Read;
    use std::io::Seek;
    use std::io::BufRead;
        let mut tmp336 = <u8>::default();
        let mut tmp1093 = <[u8; 1]>::default();
        r.read_exact(&mut tmp1093[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::kind",e))?;
        tmp336 = (tmp1093)[0 as usize];
        self.kind = TCPOptionKind::from(tmp336);
        let mut tmp339 = self.kind;
        if (tmp339 == TCPOptionKind::END_OF_OPTIONS_LIST) {
        } else if((tmp339 == TCPOptionKind::NOP)) {
        } else if((tmp339 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE)) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                self.field59 = Variant60::Variant63(Variant63::default());
            }
            let mut tmp1098 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1098[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant63::length",e))?;
            match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length = (tmp1098)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)"));
            }
            let mut tmp1103 = <[u8; 2]>::default();
            r.read_exact(&mut tmp1103[0..2 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant63::mss",e))?;
            let mut tmp1104 = 0;
            while((tmp1104 < 2)) {
                match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss = (match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss | (((tmp1103)[tmp1104 as usize] as u16) << ((1 - tmp1104) * 8)));
                tmp1104+= 1;
            }
        } else if((tmp339 == TCPOptionKind::WINDOW_SCALE)) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                self.field59 = Variant60::Variant66(Variant66::default());
            }
            let mut tmp1115 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1115[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant66::length",e))?;
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length = (tmp1115)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)"));
            }
            let mut tmp1120 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1120[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant66::shiftCount",e))?;
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.shiftCount = (tmp1120)[0 as usize];
        } else if((tmp339 == TCPOptionKind::SACK_PERMITTED)) {
            if !matches!(self.field59,Variant60::Variant69(_)) {
                self.field59 = Variant60::Variant69(Variant69::default());
            }
            let mut tmp1125 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1125[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant69::length",e))?;
            match &mut self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length = (tmp1125)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)"));
            }
        } else if((tmp339 == TCPOptionKind::SACK)) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                self.field59 = Variant60::Variant71(Variant71::default());
            }
            let mut tmp1130 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1130[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant71::length",e))?;
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length = (tmp1130)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            let mut tmp_array368 :Vec<u8> = vec![0; (match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize];
            r.read_exact(&mut tmp_array368).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant71::sack",e))?;
            let mut cursor368 = std::io::Cursor::new(&tmp_array368);
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.sack.decode(&mut cursor368)?;
            if cursor368.position() != (match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize,cursor368.position() as usize));
            }
        } else if((tmp339 == TCPOptionKind::TIMESTAMP)) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                self.field59 = Variant60::Variant76(Variant76::default());
            }
            let mut tmp1135 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1135[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant76::length",e))?;
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length = (tmp1135)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)"));
            }
            let mut tmp_array374 :Vec<u8> = vec![0; (match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize];
            r.read_exact(&mut tmp_array374).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant76::timestamp",e))?;
            let mut cursor374 = std::io::Cursor::new(&tmp_array374);
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.timestamp.decode(&mut cursor374)?;
            if cursor374.position() != (match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as u64 {
                return Err(Error::ArrayLengthMismatch("encode ",(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize,cursor374.position() as usize));
            }
        } else {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                self.field59 = Variant60::Variant81(Variant81::default());
            }
            let mut tmp1140 = <[u8; 1]>::default();
            r.read_exact(&mut tmp1140[0..1 as usize]).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant81::length",e))?;
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length = (tmp1140)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            let mut tmp377 = (match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length - 2);
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data.to_mut().resize(tmp377 as usize,0);
            r.read_exact(match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data.to_mut()).map_err(|e| Error::DecodeError("TCPOption::Variant60::Variant81::data",e))?;
        }
        return Ok(());
    }
}
impl <'a>TCPOption<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp336 = <u8>::default();
        let mut tmp1093 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("TCPOption::kind",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1093.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp336 = (tmp1093)[0 as usize];
        self.kind = TCPOptionKind::from(tmp336);
        let mut tmp339 = self.kind;
        if (tmp339 == TCPOptionKind::END_OF_OPTIONS_LIST) {
        } else if((tmp339 == TCPOptionKind::NOP)) {
        } else if((tmp339 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE)) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                self.field59 = Variant60::Variant63(Variant63::default());
            }
            let mut tmp1098 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant63::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1098.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length = (tmp1098)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length == 4)"));
            }
            let mut tmp1103 = <[u8; 2]>::default();
            if *offset + (2 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant63::mss",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1103.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
            *offset += (2 as usize as usize);
            let mut tmp1104 = 0;
            while((tmp1104 < 2)) {
                match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss = (match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss | (((tmp1103)[tmp1104 as usize] as u16) << ((1 - tmp1104) * 8)));
                tmp1104+= 1;
            }
        } else if((tmp339 == TCPOptionKind::WINDOW_SCALE)) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                self.field59 = Variant60::Variant66(Variant66::default());
            }
            let mut tmp1115 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant66::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1115.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length = (tmp1115)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length == 3)"));
            }
            let mut tmp1120 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant66::shiftCount",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1120.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.shiftCount = (tmp1120)[0 as usize];
        } else if((tmp339 == TCPOptionKind::SACK_PERMITTED)) {
            if !matches!(self.field59,Variant60::Variant69(_)) {
                self.field59 = Variant60::Variant69(Variant69::default());
            }
            let mut tmp1125 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant69::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1125.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length = (tmp1125)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length == 2)"));
            }
        } else if((tmp339 == TCPOptionKind::SACK)) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                self.field59 = Variant60::Variant71(Variant71::default());
            }
            let mut tmp1130 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant71::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1130.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length = (tmp1130)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            if *offset + ((match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant71::sack",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            let tmp_array368 = &r[*offset..(*offset + ((match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize))];
            *offset += ((match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize);
            let mut offset368 = 0;
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.sack.decode_direct(tmp_array368, &mut offset368)?;
            if offset368 != ((match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize) {
                return Err(Error::ArrayLengthMismatch("decode ",(match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length - 2) as usize,offset368 as usize));
            }
        } else if((tmp339 == TCPOptionKind::TIMESTAMP)) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                self.field59 = Variant60::Variant76(Variant76::default());
            }
            let mut tmp1135 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant76::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1135.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length = (tmp1135)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length == 10)"));
            }
            if *offset + ((match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant76::timestamp",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            let tmp_array374 = &r[*offset..(*offset + ((match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize))];
            *offset += ((match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize);
            let mut offset374 = 0;
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.timestamp.decode_direct(tmp_array374, &mut offset374)?;
            if offset374 != ((match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize) {
                return Err(Error::ArrayLengthMismatch("decode ",(match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length - 2) as usize,offset374 as usize));
            }
        } else {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                self.field59 = Variant60::Variant81(Variant81::default());
            }
            let mut tmp1140 = <[u8; 1]>::default();
            if *offset + (1 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant81::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            tmp1140.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
            *offset += (1 as usize as usize);
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length = (tmp1140)[0 as usize];
            if(!(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)) { 
            return Err(Error::AssertError("(match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length >= 2)"));
            }
            let mut tmp377 = (match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length - 2);
            if *offset + (tmp377 as usize as usize) > r.len() {
            return Err(Error::DecodeError("TCPOption::Variant60::Variant81::data",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
            }
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data = std::borrow::Cow::Borrowed(&r[*offset..(*offset + (tmp377 as usize as usize))]);
            *offset += (tmp377 as usize as usize);
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>SackBlock<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp1145 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1145[0..4 as usize]).map_err(|e| Error::DecodeError("SackBlock::left",e))?;
        let mut tmp1146 = 0;
        while((tmp1146 < 4)) {
            self.left = (self.left | (((tmp1145)[tmp1146 as usize] as u32) << ((3 - tmp1146) * 8)));
            tmp1146+= 1;
        }
        let mut tmp1157 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1157[0..4 as usize]).map_err(|e| Error::DecodeError("SackBlock::right",e))?;
        let mut tmp1158 = 0;
        while((tmp1158 < 4)) {
            self.right = (self.right | (((tmp1157)[tmp1158 as usize] as u32) << ((3 - tmp1158) * 8)));
            tmp1158+= 1;
        }
        return Ok(());
    }
}
impl <'a>SackBlock<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp1145 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("SackBlock::left",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1145.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1146 = 0;
        while((tmp1146 < 4)) {
            self.left = (self.left | (((tmp1145)[tmp1146 as usize] as u32) << ((3 - tmp1146) * 8)));
            tmp1146+= 1;
        }
        let mut tmp1157 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("SackBlock::right",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1157.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1158 = 0;
        while((tmp1158 < 4)) {
            self.right = (self.right | (((tmp1157)[tmp1158 as usize] as u32) << ((3 - tmp1158) * 8)));
            tmp1158+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>Sack<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read + std::io::BufRead>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        while(r.fill_buf().map(|b| !b.is_empty()).map_err(|e| Error::DecodeError("Sack::blocks",e))?) {
            let mut tmp383 = <SackBlock<'a>>::default();
            tmp383.decode(r)?;
            self.blocks.to_mut().push(tmp383);
        }
        return Ok(());
    }
}
impl <'a>Sack<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        while((*offset < r.len())) {
            let mut tmp383 = <SackBlock<'a>>::default();
            tmp383.decode_direct(r, offset)?;
            self.blocks.to_mut().push(tmp383);
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Timestamp<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp1169 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1169[0..4 as usize]).map_err(|e| Error::DecodeError("Timestamp::value",e))?;
        let mut tmp1170 = 0;
        while((tmp1170 < 4)) {
            self.value = (self.value | (((tmp1169)[tmp1170 as usize] as u32) << ((3 - tmp1170) * 8)));
            tmp1170+= 1;
        }
        let mut tmp1181 = <[u8; 4]>::default();
        r.read_exact(&mut tmp1181[0..4 as usize]).map_err(|e| Error::DecodeError("Timestamp::echoReply",e))?;
        let mut tmp1182 = 0;
        while((tmp1182 < 4)) {
            self.echoReply = (self.echoReply | (((tmp1181)[tmp1182 as usize] as u32) << ((3 - tmp1182) * 8)));
            tmp1182+= 1;
        }
        return Ok(());
    }
}
impl <'a>Timestamp<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp1169 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Timestamp::value",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1169.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1170 = 0;
        while((tmp1170 < 4)) {
            self.value = (self.value | (((tmp1169)[tmp1170 as usize] as u32) << ((3 - tmp1170) * 8)));
            tmp1170+= 1;
        }
        let mut tmp1181 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Timestamp::echoReply",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp1181.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp1182 = 0;
        while((tmp1182 < 4)) {
            self.echoReply = (self.echoReply | (((tmp1181)[tmp1182 as usize] as u32) << ((3 - tmp1182) * 8)));
            tmp1182+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn data(&self) -> std::option::Option<&std::borrow::Cow<'a,[u8]>> {
        let mut tmp86 = self.kind;
        if ((tmp86 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp86 == TCPOptionKind::NOP) || ((tmp86 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp86 == TCPOptionKind::WINDOW_SCALE) || ((tmp86 == TCPOptionKind::SACK_PERMITTED) || ((tmp86 == TCPOptionKind::SACK) || (tmp86 == TCPOptionKind::TIMESTAMP))))))) {
            return None;
        }
        if true {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_data(&mut self, param407: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        let mut tmp86 = self.kind;
        if ((tmp86 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp86 == TCPOptionKind::NOP) || ((tmp86 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp86 == TCPOptionKind::WINDOW_SCALE) || ((tmp86 == TCPOptionKind::SACK_PERMITTED) || ((tmp86 == TCPOptionKind::SACK) || (tmp86 == TCPOptionKind::TIMESTAMP))))))) {
            return Err(Error::PropertySetterError("TCPOption::data"));
        }
        if true {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                self.field59 = Variant60::Variant81(Variant81::default());
            }
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.data = param407;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::data"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn length(&self) -> std::option::Option<&u8> {
        let mut tmp119 = self.kind;
        if ((tmp119 == TCPOptionKind::END_OF_OPTIONS_LIST) || (tmp119 == TCPOptionKind::NOP)) {
            return None;
        }
        if (tmp119 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length);
        }
        if (tmp119 == TCPOptionKind::WINDOW_SCALE) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length);
        }
        if (tmp119 == TCPOptionKind::SACK_PERMITTED) {
            if !matches!(self.field59,Variant60::Variant69(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length);
        }
        if (tmp119 == TCPOptionKind::SACK) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length);
        }
        if (tmp119 == TCPOptionKind::TIMESTAMP) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length);
        }
        if true {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_length(&mut self, param427: u8) -> std::result::Result<(), Error> {
        let mut tmp119 = self.kind;
        if ((tmp119 == TCPOptionKind::END_OF_OPTIONS_LIST) || (tmp119 == TCPOptionKind::NOP)) {
            return Err(Error::PropertySetterError("TCPOption::length"));
        }
        if (tmp119 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                self.field59 = Variant60::Variant63(Variant63::default());
            }
            match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        if (tmp119 == TCPOptionKind::WINDOW_SCALE) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                self.field59 = Variant60::Variant66(Variant66::default());
            }
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        if (tmp119 == TCPOptionKind::SACK_PERMITTED) {
            if !matches!(self.field59,Variant60::Variant69(_)) {
                self.field59 = Variant60::Variant69(Variant69::default());
            }
            match &mut self.field59 {  Variant60::Variant69(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        if (tmp119 == TCPOptionKind::SACK) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                self.field59 = Variant60::Variant71(Variant71::default());
            }
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        if (tmp119 == TCPOptionKind::TIMESTAMP) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                self.field59 = Variant60::Variant76(Variant76::default());
            }
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        if true {
            if !matches!(self.field59,Variant60::Variant81(_)) {
                self.field59 = Variant60::Variant81(Variant81::default());
            }
            match &mut self.field59 {  Variant60::Variant81(x) => x, _ => unreachable!() }.length = param427;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::length"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn mss(&self) -> std::option::Option<&u16> {
        let mut tmp156 = self.kind;
        if ((tmp156 == TCPOptionKind::END_OF_OPTIONS_LIST) || (tmp156 == TCPOptionKind::NOP)) {
            return None;
        }
        if (tmp156 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_mss(&mut self, param441: u16) -> std::result::Result<(), Error> {
        let mut tmp156 = self.kind;
        if ((tmp156 == TCPOptionKind::END_OF_OPTIONS_LIST) || (tmp156 == TCPOptionKind::NOP)) {
            return Err(Error::PropertySetterError("TCPOption::mss"));
        }
        if (tmp156 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) {
            if !matches!(self.field59,Variant60::Variant63(_)) {
                self.field59 = Variant60::Variant63(Variant63::default());
            }
            match &mut self.field59 {  Variant60::Variant63(x) => x, _ => unreachable!() }.mss = param441;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::mss"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn sack(&self) -> std::option::Option<&Sack<'a>> {
        let mut tmp171 = self.kind;
        if ((tmp171 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp171 == TCPOptionKind::NOP) || ((tmp171 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp171 == TCPOptionKind::WINDOW_SCALE) || (tmp171 == TCPOptionKind::SACK_PERMITTED))))) {
            return None;
        }
        if (tmp171 == TCPOptionKind::SACK) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.sack);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_sack(&mut self, param453: Sack<'a>) -> std::result::Result<(), Error> {
        let mut tmp171 = self.kind;
        if ((tmp171 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp171 == TCPOptionKind::NOP) || ((tmp171 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp171 == TCPOptionKind::WINDOW_SCALE) || (tmp171 == TCPOptionKind::SACK_PERMITTED))))) {
            return Err(Error::PropertySetterError("TCPOption::sack"));
        }
        if (tmp171 == TCPOptionKind::SACK) {
            if !matches!(self.field59,Variant60::Variant71(_)) {
                self.field59 = Variant60::Variant71(Variant71::default());
            }
            match &mut self.field59 {  Variant60::Variant71(x) => x, _ => unreachable!() }.sack = param453;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::sack"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn shiftCount(&self) -> std::option::Option<&u8> {
        let mut tmp198 = self.kind;
        if ((tmp198 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp198 == TCPOptionKind::NOP) || (tmp198 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE))) {
            return None;
        }
        if (tmp198 == TCPOptionKind::WINDOW_SCALE) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.shiftCount);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_shiftCount(&mut self, param465: u8) -> std::result::Result<(), Error> {
        let mut tmp198 = self.kind;
        if ((tmp198 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp198 == TCPOptionKind::NOP) || (tmp198 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE))) {
            return Err(Error::PropertySetterError("TCPOption::shiftCount"));
        }
        if (tmp198 == TCPOptionKind::WINDOW_SCALE) {
            if !matches!(self.field59,Variant60::Variant66(_)) {
                self.field59 = Variant60::Variant66(Variant66::default());
            }
            match &mut self.field59 {  Variant60::Variant66(x) => x, _ => unreachable!() }.shiftCount = param465;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::shiftCount"));
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn timestamp(&self) -> std::option::Option<&Timestamp<'a>> {
        let mut tmp217 = self.kind;
        if ((tmp217 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp217 == TCPOptionKind::NOP) || ((tmp217 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp217 == TCPOptionKind::WINDOW_SCALE) || ((tmp217 == TCPOptionKind::SACK_PERMITTED) || (tmp217 == TCPOptionKind::SACK)))))) {
            return None;
        }
        if (tmp217 == TCPOptionKind::TIMESTAMP) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                return None;
            }
            return Some(&match &self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.timestamp);
        }
        return None;
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>TCPOption<'a> {
    pub fn set_timestamp(&mut self, param479: Timestamp<'a>) -> std::result::Result<(), Error> {
        let mut tmp217 = self.kind;
        if ((tmp217 == TCPOptionKind::END_OF_OPTIONS_LIST) || ((tmp217 == TCPOptionKind::NOP) || ((tmp217 == TCPOptionKind::MAXIMUM_SEGMENT_SIZE) || ((tmp217 == TCPOptionKind::WINDOW_SCALE) || ((tmp217 == TCPOptionKind::SACK_PERMITTED) || (tmp217 == TCPOptionKind::SACK)))))) {
            return Err(Error::PropertySetterError("TCPOption::timestamp"));
        }
        if (tmp217 == TCPOptionKind::TIMESTAMP) {
            if !matches!(self.field59,Variant60::Variant76(_)) {
                self.field59 = Variant60::Variant76(Variant76::default());
            }
            match &mut self.field59 {  Variant60::Variant76(x) => x, _ => unreachable!() }.timestamp = param479;
            return Ok(());
        }
        return Err(Error::PropertySetterError("TCPOption::timestamp"));
    }
}

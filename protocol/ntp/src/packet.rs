// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct Leap(u8);
impl Leap  {
    pub const NoWarning:Self = Self(0);
    pub const LastMinute61:Self = Self(1);
    pub const LastMinute59:Self = Self(2);
    pub const Unsyncronized:Self = Self(3);
}
impl std::fmt::Display for Leap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Leap::NoWarning => write!(f, "{}", "NoWarning"),
            Leap::LastMinute61 => write!(f, "{}", "LastMinute61"),
            Leap::LastMinute59 => write!(f, "{}", "LastMinute59"),
            Leap::Unsyncronized => write!(f, "{}", "Unsyncronized"),
            _ => write!(f, "Leap({})",self.0),
        }
    }
}
impl std::convert::From<Leap> for std::option::Option<&str> {
    fn from(e: Leap) -> Self {
        match e {
            Leap::NoWarning => Some("NoWarning"),
            Leap::LastMinute61 => Some("LastMinute61"),
            Leap::LastMinute59 => Some("LastMinute59"),
            Leap::Unsyncronized => Some("Unsyncronized"),
            _ =>  None,
        }
    }
}
impl Leap {
    pub fn is_known(&self) -> bool {
        match *self {
            Leap::NoWarning => true,
            Leap::LastMinute61 => true,
            Leap::LastMinute59 => true,
            Leap::Unsyncronized => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for Leap {
    fn from(e: u8) -> Self {
        Self(e)
    }
}
impl std::convert::From<Leap> for u8 {
    fn from(e: Leap) -> Self {
        e.0
    }
}
#[derive(Debug,Default, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct Mode(u8);
impl Mode  {
    pub const Reserved:Self = Self(0);
    pub const SymmetricActive:Self = Self(1);
    pub const SymmetricPassive:Self = Self(2);
    pub const Client:Self = Self(3);
    pub const Server:Self = Self(4);
    pub const Broadcast:Self = Self(5);
    pub const ReservedForNtpControlMessage:Self = Self(6);
    pub const ReservedForPrivateUse:Self = Self(7);
}
impl std::fmt::Display for Mode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Mode::Reserved => write!(f, "{}", "Reserved"),
            Mode::SymmetricActive => write!(f, "{}", "SymmetricActive"),
            Mode::SymmetricPassive => write!(f, "{}", "SymmetricPassive"),
            Mode::Client => write!(f, "{}", "Client"),
            Mode::Server => write!(f, "{}", "Server"),
            Mode::Broadcast => write!(f, "{}", "Broadcast"),
            Mode::ReservedForNtpControlMessage => write!(f, "{}", "ReservedForNtpControlMessage"),
            Mode::ReservedForPrivateUse => write!(f, "{}", "ReservedForPrivateUse"),
            _ => write!(f, "Mode({})",self.0),
        }
    }
}
impl std::convert::From<Mode> for std::option::Option<&str> {
    fn from(e: Mode) -> Self {
        match e {
            Mode::Reserved => Some("Reserved"),
            Mode::SymmetricActive => Some("SymmetricActive"),
            Mode::SymmetricPassive => Some("SymmetricPassive"),
            Mode::Client => Some("Client"),
            Mode::Server => Some("Server"),
            Mode::Broadcast => Some("Broadcast"),
            Mode::ReservedForNtpControlMessage => Some("ReservedForNtpControlMessage"),
            Mode::ReservedForPrivateUse => Some("ReservedForPrivateUse"),
            _ =>  None,
        }
    }
}
impl Mode {
    pub fn is_known(&self) -> bool {
        match *self {
            Mode::Reserved => true,
            Mode::SymmetricActive => true,
            Mode::SymmetricPassive => true,
            Mode::Client => true,
            Mode::Server => true,
            Mode::Broadcast => true,
            Mode::ReservedForNtpControlMessage => true,
            Mode::ReservedForPrivateUse => true,
            _ => false,
        }
    }
}
impl std::convert::From<u8> for Mode {
    fn from(e: u8) -> Self {
        Self(e)
    }
}
impl std::convert::From<Mode> for u8 {
    fn from(e: Mode) -> Self {
        e.0
    }
}
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
impl <'a>NtpPacket<'a> {
    pub fn leap(&self) -> Leap {
        (((self.field_46>>6) & 3) as u8).into()}
    pub fn set_leap(&mut self, value: Leap) -> bool {
        if u8::from(value) > 3 {
        return false;
        }
        self.field_46 = self.field_46& !(3<< 6) | (u8::from(value) << 6);
        true
    }
}
impl <'a>NtpPacket<'a> {
    pub fn version(&self) -> u8 {
        ((self.field_46>>3) & 7) as u8}
    pub fn set_version(&mut self, value: u8) -> bool {
        if (value as u8) > 7 {
        return false;
        }
        self.field_46 = self.field_46& !(7<< 3) | ((value as u8) << 3);
        true
    }
}
impl <'a>NtpPacket<'a> {
    pub fn mode(&self) -> Mode {
        (((self.field_46>>0) & 7) as u8).into()}
    pub fn set_mode(&mut self, value: Mode) -> bool {
        if u8::from(value) > 7 {
        return false;
        }
        self.field_46 = self.field_46& !(7<< 0) | (u8::from(value) << 0);
        true
    }
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ShortFormat<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub seconds: u16,
    pub fraction: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Timestamp<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub seconds: u32,
    pub fraction: u32,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Extension<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub type_: u16,
    pub length: u16,
    pub value: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct ReferenceID<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub id: [u8; 4],
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct Auth<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub key_id: u32,
    pub digest: std::borrow::Cow<'a,[u8]>,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct NtpPacket<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    field_46 :u8,/*leap :2*/
    /*version :3*/
    /*mode :3*/
    
    
    
    pub stratum: u8,
    pub poll: u8,
    pub precision: i8,
    pub root_delay: ShortFormat<'a>,
    pub root_dispersion: ShortFormat<'a>,
    pub reference_id: ReferenceID<'a>,
    pub reference_timestamp: Timestamp<'a>,
    pub origin_timestamp: Timestamp<'a>,
    pub receive_timestamp: Timestamp<'a>,
    pub transmit_timestamp: Timestamp<'a>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ShortFormat<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp216 = <[u8; 2]>::default();
        let mut tmp218 = 0;
        while((tmp218 < 2)) {
            (tmp216)[tmp218 as usize] = (((self.seconds >> ((1 - tmp218) * 8)) & 255) as u8);
            tmp218+= 1;
        }
        w.write_all(&tmp216[0..2 as usize]).map_err(|e| Error::EncodeError("ShortFormat::seconds",e))?;
        let mut tmp230 = <[u8; 2]>::default();
        let mut tmp231 = 0;
        while((tmp231 < 2)) {
            (tmp230)[tmp231 as usize] = (((self.fraction >> ((1 - tmp231) * 8)) & 255) as u8);
            tmp231+= 1;
        }
        w.write_all(&tmp230[0..2 as usize]).map_err(|e| Error::EncodeError("ShortFormat::fraction",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Timestamp<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp242 = <[u8; 4]>::default();
        let mut tmp243 = 0;
        while((tmp243 < 4)) {
            (tmp242)[tmp243 as usize] = (((self.seconds >> ((3 - tmp243) * 8)) & 255) as u8);
            tmp243+= 1;
        }
        w.write_all(&tmp242[0..4 as usize]).map_err(|e| Error::EncodeError("Timestamp::seconds",e))?;
        let mut tmp254 = <[u8; 4]>::default();
        let mut tmp255 = 0;
        while((tmp255 < 4)) {
            (tmp254)[tmp255 as usize] = (((self.fraction >> ((3 - tmp255) * 8)) & 255) as u8);
            tmp255+= 1;
        }
        w.write_all(&tmp254[0..4 as usize]).map_err(|e| Error::EncodeError("Timestamp::fraction",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Extension<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp266 = <[u8; 2]>::default();
        let mut tmp267 = 0;
        while((tmp267 < 2)) {
            (tmp266)[tmp267 as usize] = (((self.type_ >> ((1 - tmp267) * 8)) & 255) as u8);
            tmp267+= 1;
        }
        w.write_all(&tmp266[0..2 as usize]).map_err(|e| Error::EncodeError("Extension::type_",e))?;
        let mut tmp278 = <[u8; 2]>::default();
        let mut tmp279 = 0;
        while((tmp279 < 2)) {
            (tmp278)[tmp279 as usize] = (((self.length >> ((1 - tmp279) * 8)) & 255) as u8);
            tmp279+= 1;
        }
        w.write_all(&tmp278[0..2 as usize]).map_err(|e| Error::EncodeError("Extension::length",e))?;
        let mut tmp72 = self.length;
        if self.value.len() != tmp72 as usize {
        return Err(Error::ArrayLengthMismatch("encode Extension::value", tmp72 as usize, self.value.len()));
        }
        w.write_all(&self.value[0..self.value.len() as usize]).map_err(|e| Error::EncodeError("Extension::value",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>ReferenceID<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        w.write_all(&self.id[0..4 as usize]).map_err(|e| Error::EncodeError("ReferenceID::id",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Auth<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp290 = <[u8; 4]>::default();
        let mut tmp291 = 0;
        while((tmp291 < 4)) {
            (tmp290)[tmp291 as usize] = (((self.key_id >> ((3 - tmp291) * 8)) & 255) as u8);
            tmp291+= 1;
        }
        w.write_all(&tmp290[0..4 as usize]).map_err(|e| Error::EncodeError("Auth::key_id",e))?;
        w.write_all(&self.digest[0..self.digest.len() as usize]).map_err(|e| Error::EncodeError("Auth::digest",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>NtpPacket<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp152 = <u8>::default();
        let mut tmp154 = 0;
        tmp154 = (tmp154 + 2);
        tmp152 = (tmp152 | (((u8::from(self.leap()) as u8) & 3) << (8 - tmp154)));
        tmp154 = (tmp154 + 3);
        tmp152 = (tmp152 | (((self.version() as u8) & 7) << (8 - tmp154)));
        tmp154 = (tmp154 + 3);
        tmp152 = (tmp152 | (((u8::from(self.mode()) as u8) & 7) << (8 - tmp154)));
        let mut tmp419 = <[u8; 1]>::default();
        (tmp419)[0 as usize] = tmp152;
        w.write_all(&tmp419[0..1 as usize]).map_err(|e| Error::EncodeError("NtpPacket::bit_field_leap_version_mode",e))?;
        let mut tmp303 = <[u8; 1]>::default();
        (tmp303)[0 as usize] = self.stratum;
        w.write_all(&tmp303[0..1 as usize]).map_err(|e| Error::EncodeError("NtpPacket::stratum",e))?;
        let mut tmp308 = <[u8; 1]>::default();
        (tmp308)[0 as usize] = self.poll;
        w.write_all(&tmp308[0..1 as usize]).map_err(|e| Error::EncodeError("NtpPacket::poll",e))?;
        let mut tmp313 = <[u8; 1]>::default();
        (tmp313)[0 as usize] = (self.precision as u8);
        w.write_all(&tmp313[0..1 as usize]).map_err(|e| Error::EncodeError("NtpPacket::precision",e))?;
        self.root_delay.encode(w)?;
        self.root_dispersion.encode(w)?;
        self.reference_id.encode(w)?;
        self.reference_timestamp.encode(w)?;
        self.origin_timestamp.encode(w)?;
        self.receive_timestamp.encode(w)?;
        self.transmit_timestamp.encode(w)?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>ShortFormat<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp319 = <[u8; 2]>::default();
        r.read_exact(&mut tmp319[0..2 as usize]).map_err(|e| Error::DecodeError("ShortFormat::seconds",e))?;
        let mut tmp320 = 0;
        while((tmp320 < 2)) {
            self.seconds = (self.seconds | (((tmp319)[tmp320 as usize] as u16) << ((1 - tmp320) * 8)));
            tmp320+= 1;
        }
        let mut tmp331 = <[u8; 2]>::default();
        r.read_exact(&mut tmp331[0..2 as usize]).map_err(|e| Error::DecodeError("ShortFormat::fraction",e))?;
        let mut tmp332 = 0;
        while((tmp332 < 2)) {
            self.fraction = (self.fraction | (((tmp331)[tmp332 as usize] as u16) << ((1 - tmp332) * 8)));
            tmp332+= 1;
        }
        return Ok(());
    }
}
impl <'a>ShortFormat<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp319 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("ShortFormat::seconds",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp319.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp320 = 0;
        while((tmp320 < 2)) {
            self.seconds = (self.seconds | (((tmp319)[tmp320 as usize] as u16) << ((1 - tmp320) * 8)));
            tmp320+= 1;
        }
        let mut tmp331 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("ShortFormat::fraction",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp331.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp332 = 0;
        while((tmp332 < 2)) {
            self.fraction = (self.fraction | (((tmp331)[tmp332 as usize] as u16) << ((1 - tmp332) * 8)));
            tmp332+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Timestamp<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp343 = <[u8; 4]>::default();
        r.read_exact(&mut tmp343[0..4 as usize]).map_err(|e| Error::DecodeError("Timestamp::seconds",e))?;
        let mut tmp344 = 0;
        while((tmp344 < 4)) {
            self.seconds = (self.seconds | (((tmp343)[tmp344 as usize] as u32) << ((3 - tmp344) * 8)));
            tmp344+= 1;
        }
        let mut tmp355 = <[u8; 4]>::default();
        r.read_exact(&mut tmp355[0..4 as usize]).map_err(|e| Error::DecodeError("Timestamp::fraction",e))?;
        let mut tmp356 = 0;
        while((tmp356 < 4)) {
            self.fraction = (self.fraction | (((tmp355)[tmp356 as usize] as u32) << ((3 - tmp356) * 8)));
            tmp356+= 1;
        }
        return Ok(());
    }
}
impl <'a>Timestamp<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp343 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Timestamp::seconds",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp343.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp344 = 0;
        while((tmp344 < 4)) {
            self.seconds = (self.seconds | (((tmp343)[tmp344 as usize] as u32) << ((3 - tmp344) * 8)));
            tmp344+= 1;
        }
        let mut tmp355 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Timestamp::fraction",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp355.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp356 = 0;
        while((tmp356 < 4)) {
            self.fraction = (self.fraction | (((tmp355)[tmp356 as usize] as u32) << ((3 - tmp356) * 8)));
            tmp356+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Extension<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp367 = <[u8; 2]>::default();
        r.read_exact(&mut tmp367[0..2 as usize]).map_err(|e| Error::DecodeError("Extension::type_",e))?;
        let mut tmp368 = 0;
        while((tmp368 < 2)) {
            self.type_ = (self.type_ | (((tmp367)[tmp368 as usize] as u16) << ((1 - tmp368) * 8)));
            tmp368+= 1;
        }
        let mut tmp379 = <[u8; 2]>::default();
        r.read_exact(&mut tmp379[0..2 as usize]).map_err(|e| Error::DecodeError("Extension::length",e))?;
        let mut tmp380 = 0;
        while((tmp380 < 2)) {
            self.length = (self.length | (((tmp379)[tmp380 as usize] as u16) << ((1 - tmp380) * 8)));
            tmp380+= 1;
        }
        let mut tmp83 = self.length;
        self.value.to_mut().resize(tmp83 as usize,0);
        r.read_exact(self.value.to_mut()).map_err(|e| Error::DecodeError("Extension::value",e))?;
        return Ok(());
    }
}
impl <'a>Extension<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp367 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Extension::type_",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp367.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp368 = 0;
        while((tmp368 < 2)) {
            self.type_ = (self.type_ | (((tmp367)[tmp368 as usize] as u16) << ((1 - tmp368) * 8)));
            tmp368+= 1;
        }
        let mut tmp379 = <[u8; 2]>::default();
        if *offset + (2 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Extension::length",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp379.copy_from_slice(&r[*offset..(*offset + (2 as usize as usize))]);
        *offset += (2 as usize as usize);
        let mut tmp380 = 0;
        while((tmp380 < 2)) {
            self.length = (self.length | (((tmp379)[tmp380 as usize] as u16) << ((1 - tmp380) * 8)));
            tmp380+= 1;
        }
        let mut tmp83 = self.length;
        if *offset + (tmp83 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Extension::value",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.value = std::borrow::Cow::Borrowed(&r[*offset..(*offset + (tmp83 as usize as usize))]);
        *offset += (tmp83 as usize as usize);
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>ReferenceID<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        r.read_exact(&mut self.id[0..4 as usize]).map_err(|e| Error::DecodeError("ReferenceID::id",e))?;
        return Ok(());
    }
}
impl <'a>ReferenceID<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("ReferenceID::id",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        self.id.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>Auth<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp391 = <[u8; 4]>::default();
        r.read_exact(&mut tmp391[0..4 as usize]).map_err(|e| Error::DecodeError("Auth::key_id",e))?;
        let mut tmp392 = 0;
        while((tmp392 < 4)) {
            self.key_id = (self.key_id | (((tmp391)[tmp392 as usize] as u32) << ((3 - tmp392) * 8)));
            tmp392+= 1;
        }
        r.read_to_end(self.digest.to_mut()).map_err(|e| Error::DecodeError("Auth::digest",e))?;
        return Ok(());
    }
}
impl <'a>Auth<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp391 = <[u8; 4]>::default();
        if *offset + (4 as usize as usize) > r.len() {
        return Err(Error::DecodeError("Auth::key_id",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp391.copy_from_slice(&r[*offset..(*offset + (4 as usize as usize))]);
        *offset += (4 as usize as usize);
        let mut tmp392 = 0;
        while((tmp392 < 4)) {
            self.key_id = (self.key_id | (((tmp391)[tmp392 as usize] as u32) << ((3 - tmp392) * 8)));
            tmp392+= 1;
        }
        self.digest = std::borrow::Cow::Borrowed(&r[*offset..]);
        *offset = r.len();
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>NtpPacket<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp186 = <u8>::default();
        let mut tmp187 = 0;
        let mut tmp424 = <[u8; 1]>::default();
        r.read_exact(&mut tmp424[0..1 as usize]).map_err(|e| Error::DecodeError("NtpPacket::bit_field_leap_version_mode",e))?;
        tmp186 = (tmp424)[0 as usize];
        let mut tmp89 = <u8>::default();
        tmp187 = (tmp187 + 2);
        tmp89 = (((tmp186 >> (8 - tmp187)) & 3) as u8);
        self.set_leap(Leap::from(tmp89));
        tmp187 = (tmp187 + 3);
        self.set_version((((tmp186 >> (8 - tmp187)) & 7) as u8));
        let mut tmp93 = <u8>::default();
        tmp187 = (tmp187 + 3);
        tmp93 = (((tmp186 >> (8 - tmp187)) & 7) as u8);
        self.set_mode(Mode::from(tmp93));
        let mut tmp403 = <[u8; 1]>::default();
        r.read_exact(&mut tmp403[0..1 as usize]).map_err(|e| Error::DecodeError("NtpPacket::stratum",e))?;
        self.stratum = (tmp403)[0 as usize];
        let mut tmp408 = <[u8; 1]>::default();
        r.read_exact(&mut tmp408[0..1 as usize]).map_err(|e| Error::DecodeError("NtpPacket::poll",e))?;
        self.poll = (tmp408)[0 as usize];
        let mut tmp413 = <[u8; 1]>::default();
        r.read_exact(&mut tmp413[0..1 as usize]).map_err(|e| Error::DecodeError("NtpPacket::precision",e))?;
        self.precision = ((tmp413)[0 as usize] as i8);
        self.root_delay.decode(r)?;
        self.root_dispersion.decode(r)?;
        self.reference_id.decode(r)?;
        self.reference_timestamp.decode(r)?;
        self.origin_timestamp.decode(r)?;
        self.receive_timestamp.decode(r)?;
        self.transmit_timestamp.decode(r)?;
        return Ok(());
    }
}
impl <'a>NtpPacket<'a> {
    pub fn decode_slice_direct(data :&'a [u8]) -> Result<(Self,&'a [u8]), Error> {
        let mut result = Self::default();
        let mut offset = 0;
        result.decode_direct(data,&mut offset
        )?;
        Ok((result,&data[offset..]))
    }
    pub fn decode_exact_direct(data :&'a [u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice_direct(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode_direct(&mut self, r :&'a [u8], offset :&mut usize) -> std::result::Result<(), Error> {
        let mut tmp186 = <u8>::default();
        let mut tmp187 = 0;
        let mut tmp424 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("NtpPacket::bit_field_leap_version_mode",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp424.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        tmp186 = (tmp424)[0 as usize];
        let mut tmp89 = <u8>::default();
        tmp187 = (tmp187 + 2);
        tmp89 = (((tmp186 >> (8 - tmp187)) & 3) as u8);
        self.set_leap(Leap::from(tmp89));
        tmp187 = (tmp187 + 3);
        self.set_version((((tmp186 >> (8 - tmp187)) & 7) as u8));
        let mut tmp93 = <u8>::default();
        tmp187 = (tmp187 + 3);
        tmp93 = (((tmp186 >> (8 - tmp187)) & 7) as u8);
        self.set_mode(Mode::from(tmp93));
        let mut tmp403 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("NtpPacket::stratum",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp403.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        self.stratum = (tmp403)[0 as usize];
        let mut tmp408 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("NtpPacket::poll",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp408.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        self.poll = (tmp408)[0 as usize];
        let mut tmp413 = <[u8; 1]>::default();
        if *offset + (1 as usize as usize) > r.len() {
        return Err(Error::DecodeError("NtpPacket::precision",std::io::Error::new(std::io::ErrorKind::UnexpectedEof, "Unexpected end of input")));
        }
        tmp413.copy_from_slice(&r[*offset..(*offset + (1 as usize as usize))]);
        *offset += (1 as usize as usize);
        self.precision = ((tmp413)[0 as usize] as i8);
        self.root_delay.decode_direct(r, offset)?;
        self.root_dispersion.decode_direct(r, offset)?;
        self.reference_id.decode_direct(r, offset)?;
        self.reference_timestamp.decode_direct(r, offset)?;
        self.origin_timestamp.decode_direct(r, offset)?;
        self.receive_timestamp.decode_direct(r, offset)?;
        self.transmit_timestamp.decode_direct(r, offset)?;
        return Ok(());
    }
}
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: PROPERTY_FUNCTION */
impl <'a>Extension<'a> {
    pub fn set_value(&mut self, param97: std::borrow::Cow<'a,[u8]>) -> std::result::Result<(), Error> {
        if(!(param97.len() <= 65535)) { 
        return Err(Error::AssertError("(param97.len() <= 65535)"));
        }
        self.length = (param97.len() as u16);
        self.value = param97;
        return Ok(());
    }
}

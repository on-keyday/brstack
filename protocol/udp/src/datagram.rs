// Code generated by bm2rust of https://github.com/on-keyday/rebrgen
#[derive(Debug)]
pub enum Error {
    PropertySetterError(&'static str),
    EncodeError(&'static str, std::io::Error),
    DecodeError(&'static str, std::io::Error),
    TryFromIntError(std::num::TryFromIntError),
    ArrayLengthMismatch(&'static str,usize /*expected*/,usize /*actual*/),
    AssertError(&'static str),
    InvalidUnionVariant(&'static str),
    BackwardError(usize,usize),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::PropertySetterError(s) => write!(f, "PropertySetterError: {}", s),
            Error::EncodeError(s,e) => write!(f, "EncodeError: {} {}", s,e),
            Error::DecodeError(s,e) => write!(f, "DecodeError: {} {}", s,e),
            Error::TryFromIntError(e) => write!(f, "TryFromIntError: {}", e),
            Error::ArrayLengthMismatch(s,expected,actual) => write!(f, "ArrayLengthMismatch: {} expected:{} actual:{}", s,expected,actual),
            Error::AssertError(s) => write!(f, "AssertError: {}", s),
            Error::InvalidUnionVariant(s) => write!(f, "InvalidUnionVariant: {}", s),
            Error::BackwardError(expected,actual) => write!(f, "BackwardError: expected:{} actual:{}", expected,actual),
        }
    }
}
impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::EncodeError(_,e) => Some(e),
            Error::DecodeError(_,e) => Some(e),
            Error::TryFromIntError(e) => Some(e),
            Error::PropertySetterError(_) => None,
            Error::ArrayLengthMismatch(_,_,_) => None,
            Error::AssertError(_) => None,
            Error::InvalidUnionVariant(_) => None,
            Error::BackwardError(_,_) => None,
        }
    }
}
impl From<std::num::TryFromIntError> for Error {
    fn from(e: std::num::TryFromIntError) -> Self {
        Error::TryFromIntError(e)
    }
}
impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        unreachable!()
    }
}
/* Unimplemented op: DECLARE_FORMAT */
/* Unimplemented op: DECLARE_FORMAT */
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct UDPHeader<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub src_port: u16,
    pub dst_port: u16,
    pub length: u16,
    pub checksum: u16,
}
#[derive(Debug,Default, Clone, PartialEq, Eq)]
pub struct UDPDatagram<'a> {
    pub _phantom: std::marker::PhantomData<&'a ()>,
    /* Unimplemented op: DEFINE_ENCODER */
    /* Unimplemented op: DEFINE_DECODER */
    pub header: UDPHeader<'a>,
    pub data: std::borrow::Cow<'a,[u8]>,
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>UDPHeader<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        let mut tmp33 = <[u8; 2]>::default();
        let mut tmp37 = 0;
        while((tmp37 < 2)) {
            (tmp33)[tmp37 as usize] = (((self.src_port >> ((1 - tmp37) * 8)) & 255) as u8);
            tmp37+= 1;
        }
        w.write_all(&tmp33[0..2 as usize]).map_err(|e| Error::EncodeError("UDPHeader::src_port",e))?;
        let mut tmp51 = <[u8; 2]>::default();
        let mut tmp52 = 0;
        while((tmp52 < 2)) {
            (tmp51)[tmp52 as usize] = (((self.dst_port >> ((1 - tmp52) * 8)) & 255) as u8);
            tmp52+= 1;
        }
        w.write_all(&tmp51[0..2 as usize]).map_err(|e| Error::EncodeError("UDPHeader::dst_port",e))?;
        let mut tmp63 = <[u8; 2]>::default();
        let mut tmp64 = 0;
        while((tmp64 < 2)) {
            (tmp63)[tmp64 as usize] = (((self.length >> ((1 - tmp64) * 8)) & 255) as u8);
            tmp64+= 1;
        }
        w.write_all(&tmp63[0..2 as usize]).map_err(|e| Error::EncodeError("UDPHeader::length",e))?;
        let mut tmp75 = <[u8; 2]>::default();
        let mut tmp76 = 0;
        while((tmp76 < 2)) {
            (tmp75)[tmp76 as usize] = (((self.checksum >> ((1 - tmp76) * 8)) & 255) as u8);
            tmp76+= 1;
        }
        w.write_all(&tmp75[0..2 as usize]).map_err(|e| Error::EncodeError("UDPHeader::checksum",e))?;
        return Ok(());
    }
}
/* Unimplemented op: ENCODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>UDPDatagram<'a> {
    pub fn encode_to_vec(&self) -> std::result::Result<Vec<u8>, Error> {
        let mut w = std::io::Cursor::new(Vec::new());
        self.encode(&mut w
        )?;
        Ok(w.into_inner())
    }
    pub fn encode_to_fixed<'b>(&self, data: &'b mut [u8]) -> std::result::Result<&'b [u8], Error> {
        let mut w = std::io::Cursor::new(&mut *data);
        self.encode(&mut w
        )?;
        let written = w.position() as usize;
        drop(w);
        Ok(&data[0..written])
    }
    pub fn encode<W: std::io::Write>(&self, w :&mut W) -> std::result::Result<(), Error> {
        self.header.encode(w)?;
        if(!(self.header.length >= 8)) { 
        return Err(Error::AssertError("(self.header.length >= 8)"));
        }
        let mut tmp22 = (self.header.length - 8);
        if self.data.len() != tmp22 as usize {
        return Err(Error::ArrayLengthMismatch("encode UDPDatagram::data", tmp22 as usize, self.data.len()));
        }
        w.write_all(&self.data[0..self.data.len() as usize]).map_err(|e| Error::EncodeError("UDPDatagram::data",e))?;
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
/* Unimplemented op: DEFINE_FALLBACK */
/* Unimplemented op: END_FALLBACK */
impl <'a>UDPHeader<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        let mut tmp87 = <[u8; 2]>::default();
        r.read_exact(&mut tmp87[0..2 as usize]).map_err(|e| Error::DecodeError("UDPHeader::src_port",e))?;
        let mut tmp88 = 0;
        while((tmp88 < 2)) {
            self.src_port = (self.src_port | (((tmp87)[tmp88 as usize] as u16) << ((1 - tmp88) * 8)));
            tmp88+= 1;
        }
        let mut tmp99 = <[u8; 2]>::default();
        r.read_exact(&mut tmp99[0..2 as usize]).map_err(|e| Error::DecodeError("UDPHeader::dst_port",e))?;
        let mut tmp100 = 0;
        while((tmp100 < 2)) {
            self.dst_port = (self.dst_port | (((tmp99)[tmp100 as usize] as u16) << ((1 - tmp100) * 8)));
            tmp100+= 1;
        }
        let mut tmp111 = <[u8; 2]>::default();
        r.read_exact(&mut tmp111[0..2 as usize]).map_err(|e| Error::DecodeError("UDPHeader::length",e))?;
        let mut tmp112 = 0;
        while((tmp112 < 2)) {
            self.length = (self.length | (((tmp111)[tmp112 as usize] as u16) << ((1 - tmp112) * 8)));
            tmp112+= 1;
        }
        let mut tmp123 = <[u8; 2]>::default();
        r.read_exact(&mut tmp123[0..2 as usize]).map_err(|e| Error::DecodeError("UDPHeader::checksum",e))?;
        let mut tmp124 = 0;
        while((tmp124 < 2)) {
            self.checksum = (self.checksum | (((tmp123)[tmp124 as usize] as u16) << ((1 - tmp124) * 8)));
            tmp124+= 1;
        }
        return Ok(());
    }
}
/* Unimplemented op: DECODER_PARAMETER */
/* Unimplemented op: RETURN_TYPE */
impl <'a>UDPDatagram<'a> {
    pub fn decode_slice<'b>(data :&'b [u8]) -> Result<(Self,&'b [u8]), Error> {
        let mut r = std::io::Cursor::new(data);
        let mut result = Self::default();
        result.decode(&mut r)?;
        Ok((result,&data[r.position() as usize..]))
    }
    pub fn decode_exact(data :&[u8]) -> Result<Self, Error> {
        let (result,rest) = Self::decode_slice(data)?;
        if rest.len() > 0 {
        return Err(Error::AssertError("Unexpected data"));
        }
        Ok(result)
    }
    pub fn decode<R: std::io::Read>(&mut self, r :&mut R) -> std::result::Result<(), Error> {
        self.header.decode(r)?;
        if(!(self.header.length >= 8)) { 
        return Err(Error::AssertError("(self.header.length >= 8)"));
        }
        let mut tmp29 = (self.header.length - 8);
        self.data.to_mut().resize(tmp29 as usize,0);
        r.read_exact(self.data.to_mut()).map_err(|e| Error::DecodeError("UDPDatagram::data",e))?;
        return Ok(());
    }
}
